<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/JavaWizardApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/JavaWizardApplication.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import com.amankrmj.javawizard.commands.PathCommand;&#10;import com.amankrmj.javawizard.commands.java.JavaVersionManagerCommand;&#10;import com.amankrmj.javawizard.commands.native_.NativeCompilerCommand;&#10;&#10;@Command(name = &quot;javawizard&quot;,&#10;         mixinStandardHelpOptions = true,&#10;         version = &quot;1.0.0&quot;,&#10;         description = &quot;JavaWizard - Complete Java Development Environment Manager&quot;,&#10;         subcommands = {&#10;             PathCommand.class,&#10;             JavaVersionManagerCommand.class,&#10;             NativeCompilerCommand.class&#10;         })&#10;public class JavaWizardApplication implements Runnable {&#10;&#10;    @Option(names = {&quot;-v&quot;, &quot;--verbose&quot;}, description = &quot;Enable verbose output&quot;)&#10;    private boolean verbose = false;&#10;&#10;    public boolean isVerbose() {&#10;        return verbose;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;JavaWizard - Complete Java Development Environment Manager&quot;);&#10;        System.out.println(&quot;Use --help for options or try these commands:&quot;);&#10;        System.out.println(&quot;  path     - Manage environment PATH variables&quot;);&#10;        System.out.println(&quot;  java     - Manage Java versions and installations&quot;);&#10;        System.out.println(&quot;  native   - Manage native compilation and cross-platform builds&quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        CommandLine cmd = new CommandLine(new JavaWizardApplication());&#10;        int exitCode = cmd.execute(args);&#10;        System.exit(exitCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/PathCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/PathCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;path&quot;,&#10;         description = &quot;Manage environment PATH variables&quot;,&#10;         subcommands = {&#10;             PathCommand.AddCommand.class,&#10;             PathCommand.RemoveCommand.class,&#10;             PathCommand.ListCommand.class&#10;         })&#10;public class PathCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Use 'path --help' to see available subcommands:&quot;);&#10;        System.out.println(&quot;  add    - Add directory to PATH&quot;);&#10;        System.out.println(&quot;  remove - Remove directory from PATH&quot;);&#10;        System.out.println(&quot;  list   - List current PATH entries&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;add&quot;, description = &quot;Add a directory to user PATH environment variable&quot;)&#10;    static class AddCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to add to PATH&quot;)&#10;        private String pathToAdd;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Add to system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Add even if path already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                // Check if path already exists&#10;                if (!force &amp;&amp; isPathAlreadyInPATH(currentPath, pathToAdd)) {&#10;                    System.out.println(&quot;Path already exists in &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                    return 0;&#10;                }&#10;                &#10;                // Add to PATH&#10;                String newPath = currentPath.isEmpty() ? pathToAdd : currentPath + &quot;;&quot; + pathToAdd;&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully added to &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error adding to PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;remove&quot;, description = &quot;Remove a directory from user PATH environment variable&quot;)&#10;    static class RemoveCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to remove from PATH&quot;)&#10;        private String pathToRemove;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Remove from system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                if (!isPathAlreadyInPATH(currentPath, pathToRemove)) {&#10;                    System.out.println(&quot;Path not found in &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                    return 0;&#10;                }&#10;                &#10;                // Remove from PATH&#10;                String newPath = removePathFromPATH(currentPath, pathToRemove);&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully removed from &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error removing from PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List current PATH entries&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Show system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show both user and system PATH&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== USER PATH ===&quot;);&#10;                    listPath(&quot;USER&quot;);&#10;                    System.out.println(&quot;\n=== SYSTEM PATH ===&quot;);&#10;                    listPath(&quot;SYSTEM&quot;);&#10;                } else {&#10;                    String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                    System.out.println(&quot;=== &quot; + scope + &quot; PATH ===&quot;);&#10;                    listPath(scope);&#10;                }&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listPath(String scope) throws IOException, InterruptedException {&#10;            String currentPath = getCurrentPath(scope);&#10;            if (currentPath.isEmpty()) {&#10;                System.out.println(&quot;No &quot; + scope + &quot; PATH entries found.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String[] paths = currentPath.split(&quot;;&quot;);&#10;            for (int i = 0; i &lt; paths.length; i++) {&#10;                String path = paths[i].trim();&#10;                if (!path.isEmpty()) {&#10;                    System.out.println((i + 1) + &quot;. &quot; + path);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static String getCurrentPath(String scope) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, hive + &quot;\\&quot; + key, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        &#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        // Parse reg output to get PATH value&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    return parts[2].trim();&#10;                }&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;    &#10;    private static void setPathVariable(String scope, String newPath) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, hive + &quot;\\&quot; + key, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update registry: &quot; + error);&#10;        }&#10;        &#10;        // Broadcast environment change&#10;        broadcastEnvironmentChange();&#10;    }&#10;    &#10;    private static boolean isPathAlreadyInPATH(String currentPath, String pathToCheck) {&#10;        if (currentPath.isEmpty()) return false;&#10;        &#10;        List&lt;String&gt; paths = Arrays.asList(currentPath.toLowerCase().split(&quot;;&quot;));&#10;        return paths.contains(pathToCheck.toLowerCase().trim());&#10;    }&#10;    &#10;    private static String removePathFromPATH(String currentPath, String pathToRemove) {&#10;        String[] paths = currentPath.split(&quot;;&quot;);&#10;        StringBuilder newPath = new StringBuilder();&#10;        &#10;        for (String path : paths) {&#10;            String trimmedPath = path.trim();&#10;            if (!trimmedPath.isEmpty() &amp;&amp; !trimmedPath.equalsIgnoreCase(pathToRemove.trim())) {&#10;                if (newPath.length() &gt; 0) {&#10;                    newPath.append(&quot;;&quot;);&#10;                }&#10;                newPath.append(trimmedPath);&#10;            }&#10;        }&#10;        &#10;        return newPath.toString();&#10;    }&#10;    &#10;    private static void broadcastEnvironmentChange() {&#10;        try {&#10;            // Notify system of environment changes&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;powershell&quot;, &quot;-Command&quot;, &#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', [System.Guid]::NewGuid().ToString(), 'User'); &quot; +&#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', $null, 'User')&quot;);&#10;            Process process = pb.start();&#10;            process.waitFor();&#10;        } catch (Exception e) {&#10;            // Silent fail - environment change broadcast is optional&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/java/JavaVersionManagerCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/java/JavaVersionManagerCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands.java;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;import java.util.stream.Collectors;&#10;&#10;@Command(name = &quot;java&quot;,&#10;         description = &quot;Manage Java versions and installations&quot;,&#10;         subcommands = {&#10;             JavaVersionManagerCommand.ListCommand.class,&#10;             JavaVersionManagerCommand.InstallCommand.class,&#10;             JavaVersionManagerCommand.UseCommand.class,&#10;             JavaVersionManagerCommand.CurrentCommand.class,&#10;             JavaVersionManagerCommand.WhichCommand.class&#10;         })&#10;public class JavaVersionManagerCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Java Version Manager - Use 'java --help' for options:&quot;);&#10;        System.out.println(&quot;  list     - List installed Java versions&quot;);&#10;        System.out.println(&quot;  install  - Install a specific Java version&quot;);&#10;        System.out.println(&quot;  use      - Switch to a specific Java version&quot;);&#10;        System.out.println(&quot;  current  - Show current active Java version&quot;);&#10;        System.out.println(&quot;  which    - Show path to current Java installation&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List all installed Java versions&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show all detected Java installations&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== All Detected Java Installations ===&quot;);&#10;                    findAllJavaInstallations();&#10;                } else {&#10;                    System.out.println(&quot;=== Managed Java Versions ===&quot;);&#10;                    listManagedVersions();&#10;                }&#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing Java versions: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listManagedVersions() throws IOException {&#10;            Path javaVersionsDir = getJavaVersionsDirectory();&#10;            if (!Files.exists(javaVersionsDir)) {&#10;                System.out.println(&quot;No managed Java versions found.&quot;);&#10;                System.out.println(&quot;Use 'javawizard java install &lt;version&gt;' to install Java versions.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String currentVersion = getCurrentJavaVersion();&#10;            &#10;            Files.list(javaVersionsDir)&#10;                .filter(Files::isDirectory)&#10;                .map(path -&gt; path.getFileName().toString())&#10;                .sorted()&#10;                .forEach(version -&gt; {&#10;                    String marker = version.equals(currentVersion) ? &quot; (current)&quot; : &quot;&quot;;&#10;                    System.out.println(&quot;  &quot; + version + marker);&#10;                });&#10;        }&#10;        &#10;        private void findAllJavaInstallations() {&#10;            // Common Java installation paths&#10;            String[] commonPaths = {&#10;                &quot;C:\\Program Files\\Java&quot;,&#10;                &quot;C:\\Program Files (x86)\\Java&quot;,&#10;                &quot;C:\\Program Files\\Eclipse Adoptium&quot;,&#10;                &quot;C:\\Program Files\\Microsoft&quot;,&#10;                System.getProperty(&quot;user.home&quot;) + &quot;\\.jdks&quot;&#10;            };&#10;            &#10;            System.out.println(&quot;Scanning common installation directories...&quot;);&#10;            &#10;            for (String basePath : commonPaths) {&#10;                File baseDir = new File(basePath);&#10;                if (baseDir.exists() &amp;&amp; baseDir.isDirectory()) {&#10;                    System.out.println(&quot;\n&quot; + basePath + &quot;:&quot;);&#10;                    File[] javaInstalls = baseDir.listFiles(File::isDirectory);&#10;                    if (javaInstalls != null) {&#10;                        for (File install : javaInstalls) {&#10;                            String version = detectJavaVersion(install);&#10;                            System.out.println(&quot;  &quot; + install.getName() + &quot; &quot; + version);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Also check JAVA_HOME&#10;            String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;            if (javaHome != null) {&#10;                System.out.println(&quot;\nJAVA_HOME: &quot; + javaHome);&#10;                System.out.println(&quot;  Version: &quot; + detectJavaVersion(new File(javaHome)));&#10;            }&#10;        }&#10;        &#10;        private String detectJavaVersion(File javaHome) {&#10;            try {&#10;                File javaBin = new File(javaHome, &quot;bin/java.exe&quot;);&#10;                if (!javaBin.exists()) {&#10;                    javaBin = new File(javaHome, &quot;bin/java&quot;);&#10;                }&#10;                &#10;                if (javaBin.exists()) {&#10;                    ProcessBuilder pb = new ProcessBuilder(javaBin.getAbsolutePath(), &quot;-version&quot;);&#10;                    Process process = pb.start();&#10;                    String output = new String(process.getErrorStream().readAllBytes());&#10;                    process.waitFor();&#10;                    &#10;                    // Parse version from output&#10;                    String[] lines = output.split(&quot;\n&quot;);&#10;                    if (lines.length &gt; 0) {&#10;                        return lines[0].replaceAll(&quot;.*\&quot;(.*)\&quot;.*&quot;, &quot;($1)&quot;);&#10;                    }&#10;                }&#10;                return &quot;(unknown)&quot;;&#10;            } catch (Exception e) {&#10;                return &quot;(error: &quot; + e.getMessage() + &quot;)&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;install&quot;, description = &quot;Install a specific Java version&quot;)&#10;    static class InstallCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Java version to install (e.g., 17, 21, 11-graalvm)&quot;)&#10;        private String version;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Force reinstall if already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            System.out.println(&quot;Installing Java &quot; + version + &quot;...&quot;);&#10;            &#10;            if (version.contains(&quot;graalvm&quot;)) {&#10;                return installGraalVM();&#10;            } else {&#10;                return installOpenJDK();&#10;            }&#10;        }&#10;        &#10;        private Integer installGraalVM() {&#10;            System.out.println(&quot;GraalVM Installation Guide:&quot;);&#10;            System.out.println(&quot;1. Download GraalVM from: https://www.graalvm.org/downloads/&quot;);&#10;            System.out.println(&quot;2. Choose the appropriate version for your platform:&quot;);&#10;            System.out.println(&quot;   - Windows: graalvm-community-jdk-&lt;version&gt;_windows-x64_bin.zip&quot;);&#10;            System.out.println(&quot;   - macOS: graalvm-community-jdk-&lt;version&gt;_macos-x64_bin.tar.gz&quot;);&#10;            System.out.println(&quot;   - Linux: graalvm-community-jdk-&lt;version&gt;_linux-x64_bin.tar.gz&quot;);&#10;            System.out.println(&quot;3. Extract to: &quot; + getJavaVersionsDirectory().resolve(&quot;graalvm-&quot; + version.replace(&quot;-graalvm&quot;, &quot;&quot;)));&#10;            System.out.println(&quot;4. Run: javawizard java use graalvm-&quot; + version.replace(&quot;-graalvm&quot;, &quot;&quot;));&#10;            return 0;&#10;        }&#10;        &#10;        private Integer installOpenJDK() {&#10;            System.out.println(&quot;OpenJDK Installation Guide:&quot;);&#10;            System.out.println(&quot;1. Download from Eclipse Adoptium: https://adoptium.net/&quot;);&#10;            System.out.println(&quot;2. Choose version &quot; + version + &quot; for your platform&quot;);&#10;            System.out.println(&quot;3. Extract to: &quot; + getJavaVersionsDirectory().resolve(&quot;jdk-&quot; + version));&#10;            System.out.println(&quot;4. Run: javawizard java use jdk-&quot; + version);&#10;            System.out.println();&#10;            System.out.println(&quot;Alternative - Use package managers:&quot;);&#10;            System.out.println(&quot;Windows (winget): winget install Microsoft.OpenJDK.&quot; + version);&#10;            System.out.println(&quot;macOS (brew): brew install openjdk@&quot; + version);&#10;            System.out.println(&quot;Linux (apt): sudo apt install openjdk-&quot; + version + &quot;-jdk&quot;);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;use&quot;, description = &quot;Switch to a specific Java version&quot;)&#10;    static class UseCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Java version to use&quot;)&#10;        private String version;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                Path javaVersionsDir = getJavaVersionsDirectory();&#10;                Path versionPath = javaVersionsDir.resolve(version);&#10;                &#10;                if (!Files.exists(versionPath)) {&#10;                    System.err.println(&quot;Java version not found: &quot; + version);&#10;                    System.err.println(&quot;Available versions:&quot;);&#10;                    if (Files.exists(javaVersionsDir)) {&#10;                        Files.list(javaVersionsDir)&#10;                            .filter(Files::isDirectory)&#10;                            .map(path -&gt; path.getFileName().toString())&#10;                            .forEach(v -&gt; System.err.println(&quot;  &quot; + v));&#10;                    }&#10;                    return 1;&#10;                }&#10;                &#10;                // Set JAVA_HOME&#10;                setJavaHome(versionPath.toString());&#10;                &#10;                // Update PATH&#10;                updatePathForJava(versionPath.resolve(&quot;bin&quot;).toString());&#10;                &#10;                System.out.println(&quot;Switched to Java version: &quot; + version);&#10;                System.out.println(&quot;JAVA_HOME: &quot; + versionPath);&#10;                System.out.println(&quot;Note: Restart your terminal to see the changes.&quot;);&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error switching Java version: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;current&quot;, description = &quot;Show current active Java version&quot;)&#10;    static class CurrentCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;                if (javaHome == null) {&#10;                    System.out.println(&quot;JAVA_HOME not set&quot;);&#10;                } else {&#10;                    System.out.println(&quot;JAVA_HOME: &quot; + javaHome);&#10;                }&#10;                &#10;                // Try to get version from java command&#10;                ProcessBuilder pb = new ProcessBuilder(&quot;java&quot;, &quot;-version&quot;);&#10;                Process process = pb.start();&#10;                String output = new String(process.getErrorStream().readAllBytes());&#10;                int exitCode = process.waitFor();&#10;                &#10;                if (exitCode == 0) {&#10;                    System.out.println(&quot;Active Java version:&quot;);&#10;                    System.out.println(output.trim());&#10;                } else {&#10;                    System.out.println(&quot;No Java found in PATH&quot;);&#10;                }&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error getting current Java version: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;which&quot;, description = &quot;Show path to current Java installation&quot;)&#10;    static class WhichCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                ProcessBuilder pb = new ProcessBuilder(&quot;where&quot;, &quot;java&quot;);&#10;                Process process = pb.start();&#10;                String output = new String(process.getInputStream().readAllBytes());&#10;                int exitCode = process.waitFor();&#10;                &#10;                if (exitCode == 0) {&#10;                    System.out.println(&quot;Java executable locations:&quot;);&#10;                    System.out.println(output.trim());&#10;                } else {&#10;                    System.out.println(&quot;Java not found in PATH&quot;);&#10;                }&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error finding Java: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static Path getJavaVersionsDirectory() {&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#10;        return Paths.get(userHome, &quot;.javawizard&quot;, &quot;java-versions&quot;);&#10;    }&#10;    &#10;    private static String getCurrentJavaVersion() {&#10;        String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;        if (javaHome == null) return null;&#10;        &#10;        Path javaVersionsDir = getJavaVersionsDirectory();&#10;        Path javaHomePath = Paths.get(javaHome);&#10;        &#10;        if (javaHomePath.startsWith(javaVersionsDir)) {&#10;            return javaVersionsDir.relativize(javaHomePath).toString();&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    private static void setJavaHome(String javaHome) throws IOException, InterruptedException {&#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, &quot;HKCU\\Environment&quot;, &#10;            &quot;/v&quot;, &quot;JAVA_HOME&quot;, &quot;/t&quot;, &quot;REG_SZ&quot;, &quot;/d&quot;, javaHome, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to set JAVA_HOME: &quot; + error);&#10;        }&#10;    }&#10;    &#10;    private static void updatePathForJava(String javaBinPath) throws IOException, InterruptedException {&#10;        // Get current user PATH&#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, &quot;HKCU\\Environment&quot;, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        String currentPath = &quot;&quot;;&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    currentPath = parts[2].trim();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Remove any existing Java paths and add new one at the beginning&#10;        String[] pathParts = currentPath.split(&quot;;&quot;);&#10;        String newPath = javaBinPath + &quot;;&quot; + Arrays.stream(pathParts)&#10;            .filter(part -&gt; !part.toLowerCase().contains(&quot;java&quot;) || part.trim().isEmpty())&#10;            .collect(Collectors.joining(&quot;;&quot;));&#10;        &#10;        // Set new PATH&#10;        pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, &quot;HKCU\\Environment&quot;, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update PATH: &quot; + error);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/native_/NativeCompilerCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/native_/NativeCompilerCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands.native_;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;native&quot;,&#10;         description = &quot;Manage native compilation tools and create platform-specific executables&quot;,&#10;         subcommands = {&#10;             NativeCompilerCommand.InfoCommand.class,&#10;             NativeCompilerCommand.InstallCommand.class,&#10;             NativeCompilerCommand.BuildCommand.class,&#10;             NativeCompilerCommand.PackageCommand.class&#10;         })&#10;public class NativeCompilerCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Native Compilation Manager - Create standalone executables&quot;);&#10;        System.out.println(&quot;Available commands:&quot;);&#10;        System.out.println(&quot;  info     - Show native compilation options for current platform&quot;);&#10;        System.out.println(&quot;  install  - Install native compilation tools&quot;);&#10;        System.out.println(&quot;  build    - Build native executable&quot;);&#10;        System.out.println(&quot;  package  - Create platform-specific installers&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;info&quot;, description = &quot;Show native compilation options for current platform&quot;)&#10;    static class InfoCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            String arch = System.getProperty(&quot;os.arch&quot;);&#10;            &#10;            System.out.println(&quot;=== Native Compilation Options ===&quot;);&#10;            System.out.println(&quot;Platform: &quot; + os + &quot; (&quot; + arch + &quot;)&quot;);&#10;            System.out.println();&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                showWindowsOptions();&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                showMacOptions();&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                showLinuxOptions();&#10;            } else {&#10;                System.out.println(&quot;Unsupported platform: &quot; + os);&#10;                return 1;&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private void showWindowsOptions() {&#10;            System.out.println(&quot; WINDOWS NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates true native executables (.exe)&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;   ✅ Fast startup, low memory usage&quot;);&#10;            System.out.println(&quot;    Install: Download from graalvm.org&quot;);&#10;            System.out.println(&quot;   ️  Requires: Visual Studio Build Tools&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;            System.out.println(&quot;    Creates: .exe installer with bundled JRE&quot;);&#10;            System.out.println(&quot;   ️  Command: jpackage --input ... --main-jar ...&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;3. Launch4j + Inno Setup&quot;);&#10;            System.out.println(&quot;   ⚠️  Requires JVM on target machine&quot;);&#10;            System.out.println(&quot;    Creates: .exe wrapper + installer&quot;);&#10;            System.out.println(&quot;    Smaller download, JVM dependency&quot;);&#10;        }&#10;        &#10;        private void showMacOptions() {&#10;            System.out.println(&quot; macOS NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates native Mach-O executables&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;    Install: brew install --cask graalvm/tap/graalvm-jdk21&quot;);&#10;            System.out.println(&quot;   ️  Requires: Xcode Command Line Tools&quot;);&#10;            System.out.println(&quot;    Supports: Intel &amp; Apple Silicon (M1/M2)&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;    Creates: .app bundles or .dmg installers&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;        }&#10;        &#10;        private void showLinuxOptions() {&#10;            System.out.println(&quot; LINUX NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates native ELF executables&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;    Install: sdk install java 21.0.1-graal (using SDKMAN)&quot;);&#10;            System.out.println(&quot;   ️  Requires: gcc, glibc-devel, zlib-devel&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;    Creates: .deb, .rpm packages or AppImage&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;install&quot;, description = &quot;Install native compilation tools for current platform&quot;)&#10;    static class InstallCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Tool to install: graalvm, build-tools, jpackage&quot;)&#10;        private String tool;&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            &#10;            switch (tool.toLowerCase()) {&#10;                case &quot;graalvm&quot;:&#10;                    return installGraalVM(os);&#10;                case &quot;build-tools&quot;:&#10;                    return installBuildTools(os);&#10;                case &quot;jpackage&quot;:&#10;                    return installJPackage(os);&#10;                default:&#10;                    System.err.println(&quot;Unknown tool: &quot; + tool);&#10;                    System.err.println(&quot;Available tools: graalvm, build-tools, jpackage&quot;);&#10;                    return 1;&#10;            }&#10;        }&#10;        &#10;        private Integer installGraalVM(String os) {&#10;            System.out.println(&quot;Installing GraalVM for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows GraalVM Installation:&quot;);&#10;                System.out.println(&quot;1. Download from: https://github.com/graalvm/graalvm-ce-builds/releases&quot;);&#10;                System.out.println(&quot;2. Or use Chocolatey: choco install graalvm&quot;);&#10;                System.out.println(&quot;3. Set JAVA_HOME and add to PATH&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS GraalVM Installation:&quot;);&#10;                System.out.println(&quot;brew install --cask graalvm/tap/graalvm-jdk21&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux GraalVM Installation:&quot;);&#10;                System.out.println(&quot;curl -s 'https://get.sdkman.io' | bash&quot;);&#10;                System.out.println(&quot;sdk install java 21.0.1-graal&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private Integer installBuildTools(String os) {&#10;            System.out.println(&quot;Installing build tools for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows Build Tools:&quot;);&#10;                System.out.println(&quot;Download Visual Studio Build Tools 2022&quot;);&#10;                System.out.println(&quot;Or Visual Studio Community with C++ workload&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS Build Tools:&quot;);&#10;                System.out.println(&quot;xcode-select --install&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux Build Tools:&quot;);&#10;                System.out.println(&quot;Ubuntu/Debian: sudo apt install build-essential zlib1g-dev&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private Integer installJPackage(String os) {&#10;            System.out.println(&quot;jpackage is included with OpenJDK 14+&quot;);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;build&quot;, description = &quot;Build native executable using available tools&quot;)&#10;    static class BuildCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-t&quot;, &quot;--tool&quot;}, description = &quot;Tool to use: graalvm, jpackage&quot;)&#10;        private String tool = &quot;graalvm&quot;;&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            if (&quot;graalvm&quot;.equals(tool)) {&#10;                System.out.println(&quot;Building with GraalVM Native Image...&quot;);&#10;                System.out.println(&quot;Use: ./gradlew nativeCompile&quot;);&#10;            } else if (&quot;jpackage&quot;.equals(tool)) {&#10;                System.out.println(&quot;Building with jpackage...&quot;);&#10;                String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;                &#10;                if (os.contains(&quot;windows&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type exe --name JavaWizard&quot;);&#10;                } else if (os.contains(&quot;mac&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type dmg --name JavaWizard&quot;);&#10;                } else if (os.contains(&quot;linux&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type deb --name javawizard&quot;);&#10;                }&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;package&quot;, description = &quot;Create platform-specific installers&quot;)&#10;    static class PackageCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            System.out.println(&quot;Creating installer for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows installer options:&quot;);&#10;                System.out.println(&quot;1. Inno Setup (current) - Creates .exe installer&quot;);&#10;                System.out.println(&quot;2. WiX Toolset - Creates .msi installer&quot;);&#10;                System.out.println(&quot;3. jpackage - Creates .exe with bundled JRE&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS installer options:&quot;);&#10;                System.out.println(&quot;1. jpackage --type dmg - Creates .dmg&quot;);&#10;                System.out.println(&quot;2. jpackage --type pkg - Creates .pkg&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux installer options:&quot;);&#10;                System.out.println(&quot;1. jpackage --type deb - Creates .deb package&quot;);&#10;                System.out.println(&quot;2. jpackage --type rpm - Creates .rpm package&quot;);&#10;                System.out.println(&quot;3. AppImage - Portable application&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/JavaWizardApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/JavaWizardApplication.java" />
              <option name="updatedContent" value="package com.amankrmj.xwizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import com.amankrmj.xwizard.commands.PathCommand;&#10;import com.amankrmj.xwizard.java.JavaVersionManagerCommand;&#10;import com.amankrmj.xwizard.java.NativeCompilerCommand;&#10;&#10;/**&#10; * JavaWizard Application - Complete Java Development Environment Manager&#10; * &#10; * This is the main application class that serves as the entry point for&#10; * the JavaWizard command-line tool.&#10; */&#10;@Command(name = &quot;javawizard&quot;,&#10;         mixinStandardHelpOptions = true,&#10;         version = &quot;1.0.0&quot;,&#10;         description = &quot;JavaWizard - Complete Java Development Environment Manager&quot;,&#10;         subcommands = {&#10;             PathCommand.class,&#10;             JavaVersionManagerCommand.class,&#10;             NativeCompilerCommand.class&#10;         })&#10;public class JavaWizardApplication implements Runnable {&#10;&#10;    @Option(names = {&quot;-v&quot;, &quot;--verbose&quot;}, description = &quot;Enable verbose output&quot;)&#10;    private boolean verbose = false;&#10;&#10;    public boolean isVerbose() {&#10;        return verbose;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;JavaWizard - Complete Java Development Environment Manager&quot;);&#10;        System.out.println(&quot;Version: 1.0.0&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Available commands:&quot;);&#10;        System.out.println(&quot;  path     - Manage environment PATH variables&quot;);&#10;        System.out.println(&quot;  java     - Manage Java versions and installations&quot;);&#10;        System.out.println(&quot;  native   - Manage native compilation and cross-platform builds&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Use 'javawizard &lt;command&gt; --help' for detailed help on each command.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Alternative entry point for the application&#10;     */&#10;    public static void main(String[] args) {&#10;        CommandLine cmd = new CommandLine(new JavaWizardApplication());&#10;        int exitCode = cmd.execute(args);&#10;        System.exit(exitCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/PathCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/PathCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.xwizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;path&quot;,&#10;         description = &quot;Manage environment PATH variables&quot;,&#10;         subcommands = {&#10;             PathCommand.AddCommand.class,&#10;             PathCommand.RemoveCommand.class,&#10;             PathCommand.ListCommand.class&#10;         })&#10;public class PathCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Use 'path --help' to see available subcommands:&quot;);&#10;        System.out.println(&quot;  add    - Add directory to PATH&quot;);&#10;        System.out.println(&quot;  remove - Remove directory from PATH&quot;);&#10;        System.out.println(&quot;  list   - List current PATH entries&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;add&quot;, description = &quot;Add a directory to user PATH environment variable&quot;)&#10;    static class AddCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to add to PATH&quot;)&#10;        private String pathToAdd;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Add to system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Add even if path already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                // Check if path already exists&#10;                if (!force &amp;&amp; isPathAlreadyInPATH(currentPath, pathToAdd)) {&#10;                    System.out.println(&quot;Path already exists in &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                    return 0;&#10;                }&#10;                &#10;                // Add to PATH&#10;                String newPath = currentPath.isEmpty() ? pathToAdd : currentPath + &quot;;&quot; + pathToAdd;&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully added to &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error adding to PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;remove&quot;, description = &quot;Remove a directory from user PATH environment variable&quot;)&#10;    static class RemoveCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to remove from PATH&quot;)&#10;        private String pathToRemove;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Remove from system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                if (!isPathAlreadyInPATH(currentPath, pathToRemove)) {&#10;                    System.out.println(&quot;Path not found in &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                    return 0;&#10;                }&#10;                &#10;                // Remove from PATH&#10;                String newPath = removePathFromPATH(currentPath, pathToRemove);&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully removed from &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error removing from PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List current PATH entries&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Show system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show both user and system PATH&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== USER PATH ===&quot;);&#10;                    listPath(&quot;USER&quot;);&#10;                    System.out.println(&quot;\n=== SYSTEM PATH ===&quot;);&#10;                    listPath(&quot;SYSTEM&quot;);&#10;                } else {&#10;                    String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                    System.out.println(&quot;=== &quot; + scope + &quot; PATH ===&quot;);&#10;                    listPath(scope);&#10;                }&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listPath(String scope) throws IOException, InterruptedException {&#10;            String currentPath = getCurrentPath(scope);&#10;            if (currentPath.isEmpty()) {&#10;                System.out.println(&quot;No &quot; + scope + &quot; PATH entries found.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String[] paths = currentPath.split(&quot;;&quot;);&#10;            for (int i = 0; i &lt; paths.length; i++) {&#10;                String path = paths[i].trim();&#10;                if (!path.isEmpty()) {&#10;                    System.out.println((i + 1) + &quot;. &quot; + path);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static String getCurrentPath(String scope) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, hive + &quot;\\&quot; + key, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        &#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        // Parse reg output to get PATH value&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    return parts[2].trim();&#10;                }&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;    &#10;    private static void setPathVariable(String scope, String newPath) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, hive + &quot;\\&quot; + key, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update registry: &quot; + error);&#10;        }&#10;        &#10;        // Broadcast environment change&#10;        broadcastEnvironmentChange();&#10;    }&#10;    &#10;    private static boolean isPathAlreadyInPATH(String currentPath, String pathToCheck) {&#10;        if (currentPath.isEmpty()) return false;&#10;        &#10;        List&lt;String&gt; paths = Arrays.asList(currentPath.toLowerCase().split(&quot;;&quot;));&#10;        return paths.contains(pathToCheck.toLowerCase().trim());&#10;    }&#10;    &#10;    private static String removePathFromPATH(String currentPath, String pathToRemove) {&#10;        String[] paths = currentPath.split(&quot;;&quot;);&#10;        StringBuilder newPath = new StringBuilder();&#10;        &#10;        for (String path : paths) {&#10;            String trimmedPath = path.trim();&#10;            if (!trimmedPath.isEmpty() &amp;&amp; !trimmedPath.equalsIgnoreCase(pathToRemove.trim())) {&#10;                if (newPath.length() &gt; 0) {&#10;                    newPath.append(&quot;;&quot;);&#10;                }&#10;                newPath.append(trimmedPath);&#10;            }&#10;        }&#10;        &#10;        return newPath.toString();&#10;    }&#10;    &#10;    private static void broadcastEnvironmentChange() {&#10;        try {&#10;            // Notify system of environment changes&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;powershell&quot;, &quot;-Command&quot;, &#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', [System.Guid]::NewGuid().ToString(), 'User'); &quot; +&#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', $null, 'User')&quot;);&#10;            Process process = pb.start();&#10;            process.waitFor();&#10;        } catch (Exception e) {&#10;            // Silent fail - environment change broadcast is optional&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>