<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/workflow-windows.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/workflow-windows.yml" />
              <option name="originalContent" value="name: Build and Release JavaWizard&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*.*.*'&#10;  workflow_dispatch:  # Allow manual trigger&#10;&#10;jobs:&#10;  build-windows:&#10;    runs-on: windows-2022&#10;&#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;&#10;    - name: Setup GraalVM&#10;      uses: graalvm/setup-graalvm@v1&#10;      with:&#10;        java-version: '21'&#10;        distribution: 'graalvm-community'&#10;        github-token: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;    - name: Setup MSBuild (Visual Studio 2022)&#10;      uses: microsoft/setup-msbuild@v1.3&#10;&#10;    - name: Setup Visual Studio Developer Command Prompt&#10;      uses: ilammy/msvc-dev-cmd@v1&#10;      with:&#10;        arch: x64&#10;        vsversion: '2022'&#10;&#10;    - name: Verify Java and GraalVM installation&#10;      run: |&#10;        java -version&#10;        native-image --version&#10;&#10;    - name: Cache Gradle dependencies&#10;      uses: actions/cache@v4&#10;      with:&#10;        path: |&#10;          ~/.gradle/caches&#10;          ~/.gradle/wrapper&#10;        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}&#10;        restore-keys: |&#10;          ${{ runner.os }}-gradle-&#10;&#10;    - name: Make gradlew executable&#10;      run: chmod +x ./gradlew&#10;      shell: bash&#10;&#10;    - name: Build JAR&#10;      run: ./gradlew build&#10;&#10;    - name: Build Native Executable&#10;      run: ./gradlew nativeCompile&#10;      shell: cmd&#10;      env:&#10;        JAVA_HOME: ${{ env.JAVA_HOME }}&#10;&#10;    - name: Verify native executable&#10;      run: |&#10;        if (Test-Path &quot;build\native\nativeCompile\javawizard.exe&quot;) {&#10;          Write-Host &quot;✅ Native executable created successfully&quot;&#10;          &amp; &quot;build\native\nativeCompile\javawizard.exe&quot; --version&#10;        } else {&#10;          Write-Host &quot;❌ Native executable not found&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Setup Inno Setup&#10;      run: |&#10;        # Download and install Inno Setup&#10;        Invoke-WebRequest -Uri &quot;https://files.jrsoftware.org/is/6/innosetup-6.2.2.exe&quot; -OutFile &quot;innosetup.exe&quot;&#10;        Start-Process -FilePath &quot;innosetup.exe&quot; -ArgumentList &quot;/VERYSILENT&quot;, &quot;/SUPPRESSMSGBOXES&quot;, &quot;/NORESTART&quot; -Wait&#10;      shell: powershell&#10;&#10;    - name: Create Installer with Inno Setup&#10;      run: |&#10;        # Add Inno Setup to PATH and compile&#10;        $env:PATH += &quot;;C:\Program Files (x86)\Inno Setup 6&quot;&#10;        iscc.exe &quot;xwizard-installer.iss&quot;&#10;      shell: powershell&#10;&#10;    - name: Verify installer creation&#10;      run: |&#10;        if (Test-Path &quot;installer\JavaWizard-Native-Setup-*.exe&quot;) {&#10;          Write-Host &quot;✅ Installer created successfully&quot;&#10;          Get-ChildItem -Path &quot;installer&quot; -Filter &quot;*.exe&quot; | ForEach-Object { &#10;            Write-Host &quot; Created: $($_.Name) (Size: $([math]::Round($_.Length/1MB, 2)) MB)&quot;&#10;          }&#10;        } else {&#10;          Write-Host &quot;❌ Installer not found&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Extract version from tag&#10;      id: version&#10;      run: |&#10;        $version = &quot;${{ github.ref_name }}&quot; -replace '^v', ''&#10;        echo &quot;VERSION=$version&quot; &gt;&gt; $env:GITHUB_OUTPUT&#10;        echo &quot;VERSION_TAG=${{ github.ref_name }}&quot; &gt;&gt; $env:GITHUB_OUTPUT&#10;      shell: powershell&#10;&#10;    - name: Rename installer with version&#10;      run: |&#10;        $version = &quot;${{ steps.version.outputs.VERSION }}&quot;&#10;        $oldName = &quot;installer\JavaWizard-Native-Setup-1.0.0.exe&quot;&#10;        $newName = &quot;installer\JavaWizard_v$version.exe&quot;&#10;        &#10;        if (Test-Path $oldName) {&#10;          Rename-Item -Path $oldName -NewName (Split-Path $newName -Leaf)&#10;          Write-Host &quot;✅ Renamed installer to: JavaWizard_v$version.exe&quot;&#10;        } else {&#10;          Write-Host &quot;❌ Original installer not found at: $oldName&quot;&#10;          Get-ChildItem -Path &quot;installer&quot; -Filter &quot;*.exe&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Upload Build Artifacts&#10;      uses: actions/upload-artifact@v4&#10;      with:&#10;        name: JavaWizard-Windows-v${{ steps.version.outputs.VERSION }}&#10;        path: |&#10;          build/native/nativeCompile/javawizard.exe&#10;          installer/*.exe&#10;          build/libs/*.jar&#10;        retention-days: 30&#10;&#10;    - name: Create GitHub Release&#10;      uses: softprops/action-gh-release@v1&#10;      env:&#10;        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;      with:&#10;        tag_name: ${{ steps.version.outputs.VERSION_TAG }}&#10;        name: JavaWizard v${{ steps.version.outputs.VERSION }}&#10;        body: |&#10;          # JavaWizard v${{ steps.version.outputs.VERSION }}&#10;          &#10;          ##  What's New&#10;          - Native Windows executable (no JDK required!)&#10;          - Complete Java development environment manager&#10;          - PATH and Java version management tools&#10;          - Cross-platform native compilation support&#10;          &#10;          ##  Downloads&#10;          - **JavaWizard_v${{ steps.version.outputs.VERSION }}.exe** - Windows installer (recommended)&#10;          &#10;          ## ️ Installation&#10;          1. Download the .exe file below&#10;          2. Run the installer&#10;          3. Use from command line: `javawizard --help`&#10;          &#10;          ##  Available Commands&#10;          - `javawizard path` - Manage environment PATH variables&#10;          - `javawizard java` - Manage Java versions and installations  &#10;          - `javawizard native` - Cross-platform native compilation tools&#10;          - `javawizard analyze` - XML analysis tools&#10;          - `javawizard convert` - XML conversion utilities&#10;          - `javawizard process` - XML processing commands&#10;          &#10;          ##  System Requirements&#10;          - Windows 10/11 (x64)&#10;          - No Java installation required!&#10;          &#10;          ##  Bug Reports&#10;          Report issues at: https://github.com/${{ github.repository }}/issues&#10;        files: |&#10;          installer/JavaWizard_v${{ steps.version.outputs.VERSION }}.exe&#10;        draft: false&#10;        prerelease: false&#10;&#10;    - name: Summary&#10;      run: |&#10;        Write-Host &quot; Build and Release Completed Successfully!&quot;&#10;        Write-Host &quot; Release: ${{ steps.version.outputs.VERSION_TAG }}&quot;&#10;        Write-Host &quot; Installer: JavaWizard_v${{ steps.version.outputs.VERSION }}.exe&quot;&#10;      shell: powershell&#10;" />
              <option name="updatedContent" value="name: Build and Release JavaWizard&#10;&#10;on:&#10;  push:&#10;    tags:&#10;      - 'v*.*.*'&#10;  workflow_dispatch:  # Allow manual trigger&#10;&#10;jobs:&#10;  build-windows:&#10;    runs-on: windows-2022&#10;&#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;&#10;    - name: Setup GraalVM&#10;      uses: graalvm/setup-graalvm@v1&#10;      with:&#10;        java-version: '21'&#10;        distribution: 'graalvm-community'&#10;        github-token: ${{ secrets.GITHUB_TOKEN }}&#10;&#10;    - name: Setup MSBuild (Visual Studio 2022)&#10;      uses: microsoft/setup-msbuild@v1.3&#10;&#10;    - name: Setup Visual Studio Developer Command Prompt&#10;      uses: ilammy/msvc-dev-cmd@v1&#10;      with:&#10;        arch: x64&#10;        vsversion: '2022'&#10;&#10;    - name: Verify Java and GraalVM installation&#10;      run: |&#10;        java -version&#10;        native-image --version&#10;&#10;    - name: Cache Gradle dependencies&#10;      uses: actions/cache@v4&#10;      with:&#10;        path: |&#10;          ~/.gradle/caches&#10;          ~/.gradle/wrapper&#10;        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}&#10;        restore-keys: |&#10;          ${{ runner.os }}-gradle-&#10;&#10;    - name: Make gradlew executable&#10;      run: chmod +x ./gradlew&#10;      shell: bash&#10;&#10;    - name: Build JAR&#10;      run: ./gradlew build&#10;&#10;    - name: Build Native Executable&#10;      run: ./gradlew nativeCompile&#10;      shell: cmd&#10;      env:&#10;        JAVA_HOME: ${{ env.JAVA_HOME }}&#10;&#10;    - name: Verify native executable&#10;      run: |&#10;        if (Test-Path &quot;build\native\nativeCompile\javawizard.exe&quot;) {&#10;          Write-Host &quot;✅ Native executable created successfully&quot;&#10;          &amp; &quot;build\native\nativeCompile\javawizard.exe&quot; --version&#10;        } else {&#10;          Write-Host &quot;❌ Native executable not found&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Create Installer with Inno Setup&#10;      run: |&#10;        # Add Inno Setup to PATH and compile&#10;        $env:PATH += &quot;;C:\Program Files (x86)\Inno Setup 6&quot;&#10;        iscc.exe &quot;xwizard-installer.iss&quot;&#10;      shell: powershell&#10;&#10;    - name: Verify installer creation&#10;      run: |&#10;        if (Test-Path &quot;installer\JavaWizard-Native-Setup-*.exe&quot;) {&#10;          Write-Host &quot;✅ Installer created successfully&quot;&#10;          Get-ChildItem -Path &quot;installer&quot; -Filter &quot;*.exe&quot; | ForEach-Object { &#10;            Write-Host &quot; Created: $($_.Name) (Size: $([math]::Round($_.Length/1MB, 2)) MB)&quot;&#10;          }&#10;        } else {&#10;          Write-Host &quot;❌ Installer not found&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Extract version from tag&#10;      id: version&#10;      run: |&#10;        $version = &quot;${{ github.ref_name }}&quot; -replace '^v', ''&#10;        echo &quot;VERSION=$version&quot; &gt;&gt; $env:GITHUB_OUTPUT&#10;        echo &quot;VERSION_TAG=${{ github.ref_name }}&quot; &gt;&gt; $env:GITHUB_OUTPUT&#10;      shell: powershell&#10;&#10;    - name: Rename installer with version&#10;      run: |&#10;        $version = &quot;${{ steps.version.outputs.VERSION }}&quot;&#10;        $oldName = &quot;installer\JavaWizard-Native-Setup-1.0.0.exe&quot;&#10;        $newName = &quot;installer\JavaWizard_v$version.exe&quot;&#10;        &#10;        if (Test-Path $oldName) {&#10;          Rename-Item -Path $oldName -NewName (Split-Path $newName -Leaf)&#10;          Write-Host &quot;✅ Renamed installer to: JavaWizard_v$version.exe&quot;&#10;        } else {&#10;          Write-Host &quot;❌ Original installer not found at: $oldName&quot;&#10;          Get-ChildItem -Path &quot;installer&quot; -Filter &quot;*.exe&quot;&#10;          exit 1&#10;        }&#10;      shell: powershell&#10;&#10;    - name: Upload Build Artifacts&#10;      uses: actions/upload-artifact@v4&#10;      with:&#10;        name: JavaWizard-Windows-v${{ steps.version.outputs.VERSION }}&#10;        path: |&#10;          build/native/nativeCompile/javawizard.exe&#10;          installer/*.exe&#10;          build/libs/*.jar&#10;        retention-days: 30&#10;&#10;    - name: Create GitHub Release&#10;      uses: softprops/action-gh-release@v1&#10;      env:&#10;        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;      with:&#10;        tag_name: ${{ steps.version.outputs.VERSION_TAG }}&#10;        name: JavaWizard v${{ steps.version.outputs.VERSION }}&#10;        body: |&#10;          # JavaWizard v${{ steps.version.outputs.VERSION }}&#10;          &#10;          ##  What's New&#10;          - Native Windows executable (no JDK required!)&#10;          - Complete Java development environment manager&#10;          - PATH and Java version management tools&#10;          - Cross-platform native compilation support&#10;          &#10;          ##  Downloads&#10;          - **JavaWizard_v${{ steps.version.outputs.VERSION }}.exe** - Windows installer (recommended)&#10;          &#10;          ## ️ Installation&#10;          1. Download the .exe file below&#10;          2. Run the installer&#10;          3. Use from command line: `javawizard --help`&#10;          &#10;          ##  Available Commands&#10;          - `javawizard path` - Manage environment PATH variables&#10;          - `javawizard java` - Manage Java versions and installations  &#10;          - `javawizard native` - Cross-platform native compilation tools&#10;          - `javawizard analyze` - XML analysis tools&#10;          - `javawizard convert` - XML conversion utilities&#10;          - `javawizard process` - XML processing commands&#10;          &#10;          ##  System Requirements&#10;          - Windows 10/11 (x64)&#10;          - No Java installation required!&#10;          &#10;          ##  Bug Reports&#10;          Report issues at: https://github.com/${{ github.repository }}/issues&#10;        files: |&#10;          installer/JavaWizard_v${{ steps.version.outputs.VERSION }}.exe&#10;        draft: false&#10;        prerelease: false&#10;&#10;    - name: Summary&#10;      run: |&#10;        Write-Host &quot; Build and Release Completed Successfully!&quot;&#10;        Write-Host &quot; Release: ${{ steps.version.outputs.VERSION_TAG }}&quot;&#10;        Write-Host &quot; Installer: JavaWizard_v${{ steps.version.outputs.VERSION }}.exe&quot;&#10;      shell: powershell" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# ‍♂️ XWizard&#10;&#10;[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://openjdk.java.net/projects/jdk/21/)&#10;[![GraalVM](https://img.shields.io/badge/GraalVM-Native-blue.svg)](https://www.graalvm.org/)&#10;[![PicoCLI](https://img.shields.io/badge/PicoCLI-4.x-green.svg)](https://picocli.info/)&#10;[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)&#10;[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey.svg)]()&#10;&#10;**XWizard** is a powerful command-line tool for Java version management that runs natively on Windows, Linux, and macOS without requiring JVM, JDK, or any external dependencies to be pre-installed.&#10;&#10;##  Table of Contents&#10;&#10;- [✨ Features](#-features)&#10;- [ Quick Start](#-quick-start)&#10;  - [Installation](#installation)&#10;  - [Basic Usage](#basic-usage)&#10;- [ Documentation](#-documentation)&#10;  - [Commands](#commands)&#10;  - [Examples](#examples)&#10;- [️ Development](#️-development)&#10;  - [Prerequisites for Building](#prerequisites-for-building)&#10;  - [Building from Source](#building-from-source)&#10;  - [Project Structure](#project-structure)&#10;  - [Technology Stack](#technology-stack)&#10;- [ Contributing](#-contributing)&#10;  - [How to Contribute](#how-to-contribute)&#10;  - [Development Guidelines](#development-guidelines)&#10;  - [Areas We Need Help With](#areas-we-need-help-with)&#10;- [ Roadmap](#-roadmap)&#10;- [ Current Sprint](#-current-sprint)&#10;- [ License](#-license)&#10;- [ Acknowledgments](#-acknowledgments)&#10;- [ Inspiration](#-inspiration)&#10;- [ Support](#-support)&#10;&#10;## ✨ Features&#10;&#10;-  **Seamless Java Version Switching** - Switch between different Java versions instantly&#10;-  **Zero Dependencies** - Runs as a native executable without requiring JVM installation&#10;-  **Cross-Platform Support** - Native binaries for Windows, Linux, and macOS&#10;- ⚡ **Lightning Fast** - Built with GraalVM Native Image for optimal performance&#10;-  **Simple CLI** - Intuitive command-line interface powered by PicoCLI&#10;-  **Developer Focused** - Designed to streamline Java development workflows&#10;&#10;##  Quick Start&#10;&#10;### Installation&#10;&#10;#### Windows&#10;```powershell&#10;# Download and run the installer&#10;.\JavaWizard-Native-Setup-1.0.0.exe&#10;```&#10;&#10;#### Linux/macOS&#10;```bash&#10;# Download the binary and make it executable&#10;chmod +x xwizard&#10;sudo mv xwizard /usr/local/bin/&#10;```&#10;&#10;### Basic Usage&#10;&#10;```bash&#10;# List available Java versions&#10;xwizard java list&#10;&#10;# Install a specific Java version&#10;xwizard java install 21&#10;&#10;# Set global Java version&#10;xwizard java global 21&#10;&#10;# Show current Java version&#10;xwizard java version&#10;&#10;# Manage PATH environment&#10;xwizard path show&#10;```&#10;&#10;##  Documentation&#10;&#10;### Commands&#10;&#10;| Command | Description |&#10;|---------|-------------|&#10;| `xwizard java list` | List all available Java versions |&#10;| `xwizard java install &lt;version&gt;` | Install a specific Java version |&#10;| `xwizard java global &lt;version&gt;` | Set global Java version |&#10;| `xwizard java version` | Show current active Java version |&#10;| `xwizard path show` | Display current PATH configuration |&#10;| `xwizard help` | Show help information |&#10;&#10;### Examples&#10;&#10;```bash&#10;# Install Java 17 and 21&#10;xwizard java install 17&#10;xwizard java install 21&#10;&#10;# Switch to Java 17 globally&#10;xwizard java global 17&#10;&#10;# Verify the switch&#10;java -version&#10;```&#10;&#10;## ️ Development&#10;&#10;### Prerequisites for Building&#10;&#10;- **JDK 21** or higher&#10;- **GraalVM Native Image** (for native compilation)&#10;- **Gradle 8+**&#10;&#10;### Building from Source&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/yourusername/xwizard.git&#10;cd xwizard&#10;&#10;# Build the JAR&#10;./gradlew build&#10;&#10;# Create native executable (requires GraalVM)&#10;./gradlew nativeCompile&#10;```&#10;&#10;### Project Structure&#10;&#10;```&#10;src/&#10;├── main/java/com/amankrmj/xwizard/&#10;│   ├── Main.java                    # Application entry point&#10;│   ├── commands/&#10;│   │   └── PathCommand.java         # PATH management commands&#10;│   └── java/&#10;│       ├── InstallJavaVersionCommand.java&#10;│       ├── JavaVersionManagerCommand.java&#10;│       ├── NativeCompilerCommand.java&#10;│       └── SetGlobalVersion.java&#10;└── main/resources/META-INF/native-image/&#10;    ├── proxy-config.json            # GraalVM proxy configuration&#10;    ├── reflect-config.json          # GraalVM reflection configuration&#10;    └── resource-config.json         # GraalVM resource configuration&#10;```&#10;&#10;### Technology Stack&#10;&#10;- **☕ Java 21** - Modern Java with latest features&#10;- **️ PicoCLI** - Powerful command-line interface framework&#10;- **⚡ GraalVM Native Image** - Ahead-of-time compilation for native executables&#10;- **️ Gradle** - Build automation and dependency management&#10;&#10;##  Contributing&#10;&#10;We welcome contributions from the community! Whether you're fixing bugs, adding new features, or improving documentation, your help is appreciated.&#10;&#10;### How to Contribute&#10;&#10;1. **Fork the repository**&#10;   ```bash&#10;   git fork https://github.com/yourusername/xwizard.git&#10;   ```&#10;&#10;2. **Create a feature branch**&#10;   ```bash&#10;   git checkout -b feature/amazing-feature&#10;   ```&#10;&#10;3. **Make your changes**&#10;   - Follow the existing code style&#10;   - Add tests for new functionality&#10;   - Update documentation as needed&#10;&#10;4. **Test your changes**&#10;   ```bash&#10;   ./gradlew test&#10;   ./gradlew nativeCompile  # Test native compilation&#10;   ```&#10;&#10;5. **Commit your changes**&#10;   ```bash&#10;   git commit -m &quot;Add amazing feature&quot;&#10;   ```&#10;&#10;6. **Push and create a Pull Request**&#10;   ```bash&#10;   git push origin feature/amazing-feature&#10;   ```&#10;&#10;### Development Guidelines&#10;&#10;- **Code Style**: Follow Java conventions and maintain consistency&#10;- **Testing**: Ensure all new features have appropriate tests&#10;- **Documentation**: Update README and inline documentation&#10;- **Native Compatibility**: Test native compilation on target platforms&#10;&#10;### Areas We Need Help With&#10;&#10;-  **Linux Distribution Support** - Package managers integration&#10;-  **macOS Optimization** - Native Apple Silicon support&#10;-  **Testing Framework** - Comprehensive test coverage&#10;-  **Documentation** - User guides and tutorials&#10;-  **Internationalization** - Multi-language support&#10;&#10;##  Roadmap&#10;&#10;- [ ] **v1.1.0**: Support for additional JVM distributions (Temurin, Corretto, etc.)&#10;- [ ] **v1.2.0**: Project-specific Java version management (.java-version files)&#10;- [ ] **v1.3.0**: Integration with popular build tools (Maven, Gradle)&#10;- [ ] **v2.0.0**: Support for other programming languages (Python, Node.js, Go, Rust)&#10;&#10;##  Current Sprint&#10;&#10;We're actively working on the following features and improvements:&#10;&#10;###  Web Interface Development&#10;- Building a visual web interface for interactive Java version management&#10;- Creating user-friendly GUI for non-CLI users&#10;- Developing real-time status dashboards and configuration panels&#10;&#10;###  Core Testing &amp; Validation&#10;- Comprehensive testing of Java version management functionality&#10;- Validating installation, switching, and global version settings&#10;- Performance benchmarking of native executables across platforms&#10;&#10;###  Native Build Optimization&#10;- Refining GraalVM native compilation process&#10;- Optimizing binary size and startup performance&#10;- Ensuring consistent behavior across Windows, Linux, and macOS&#10;&#10;*Stay tuned for updates as we enhance XWizard's capabilities!*&#10;&#10;##  License&#10;&#10;This project is licensed under the GNU Affero General Public License v3.0 (GNU AGPLv3) - see the [LICENSE](LICENSE) file for details.&#10;&#10;### License Summary&#10;&#10;The **GNU AGPLv3** is a strong copyleft license that ensures this software remains free and open source:&#10;&#10;- ✅ **You can freely**: Use, study, modify, and distribute this software&#10;- ✅ **You must**: Share the source code of any modifications or derivative works&#10;- ✅ **Network use**: If you run a modified version as a service, you must make the complete source code available&#10;- ✅ **Patent protection**: Contributors grant patent rights to users&#10;- ⚠️ **Same license**: Any larger works that include this code must also use AGPLv3&#10;&#10;This license ensures that XWizard and any improvements to it remain free and available to everyone in the community.&#10;&#10;##  Acknowledgments&#10;&#10;- **Oracle JDK 21** - For providing the modern Java platform&#10;- **GraalVM** - For enabling native compilation and ahead-of-time optimization&#10;- **PicoCLI** - For the excellent command-line interface framework&#10;&#10;##  Inspiration&#10;&#10;XWizard was inspired by excellent version management tools in the developer ecosystem:&#10;&#10;- **[SDKMAN!](https://sdkman.io/)** - The Software Development Kit Manager for managing parallel versions of multiple SDKs&#10;- **[pyenv](https://github.com/pyenv/pyenv)** - Simple Python version management that pioneered the local/global version concept&#10;&#10;These tools demonstrated the power of seamless version switching and inspired us to create a native, dependency-free solution for Java developers.&#10;&#10;##  Support&#10;&#10;-  **Bug Reports**: [Create an issue](https://github.com/yourusername/xwizard/issues/new?template=bug_report.md)&#10;-  **Feature Requests**: [Create an issue](https://github.com/yourusername/xwizard/issues/new?template=feature_request.md)&#10;-  **Discussions**: [Join our discussions](https://github.com/yourusername/xwizard/discussions)&#10;&#10;---&#10;&#10;&lt;div align=&quot;center&quot;&gt;&#10;&#10;**Made with ❤️ by the XWizard**&#10;&#10;[Website](https://xwizard.dev) • [Documentation](https://docs.xwizard.dev) • [Twitter](https://twitter.com/xwizard_dev)&#10;&#10;&lt;/div&gt;&#10;" />
              <option name="updatedContent" value="# ‍♂️ XWizard&#10;&#10;[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://openjdk.java.net/projects/jdk/21/)&#10;[![GraalVM](https://img.shields.io/badge/GraalVM-Native-blue.svg)](https://www.graalvm.org/)&#10;[![PicoCLI](https://img.shields.io/badge/PicoCLI-4.x-green.svg)](https://picocli.info/)&#10;[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)&#10;[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey.svg)]()&#10;&#10;**XWizard** is a powerful command-line tool for Java version management that runs natively on Windows, Linux, and macOS without requiring JVM, JDK, or any external dependencies to be pre-installed.&#10;&#10;##  Table of Contents&#10;&#10;- [✨ Features](#-features)&#10;- [ Quick Start](#-quick-start)&#10;  - [Installation](#installation)&#10;  - [Basic Usage](#basic-usage)&#10;- [ Documentation](#-documentation)&#10;  - [Commands](#commands)&#10;  - [Examples](#examples)&#10;- [️ Development](#️-development)&#10;  - [Prerequisites for Building](#prerequisites-for-building)&#10;  - [Building from Source](#building-from-source)&#10;  - [Project Structure](#project-structure)&#10;  - [Technology Stack](#technology-stack)&#10;- [ Contributing](#-contributing)&#10;  - [How to Contribute](#how-to-contribute)&#10;  - [Development Guidelines](#development-guidelines)&#10;  - [Areas We Need Help With](#areas-we-need-help-with)&#10;- [ Roadmap](#-roadmap)&#10;- [ Current Sprint](#-current-sprint)&#10;- [ License](#-license)&#10;- [ Acknowledgments](#-acknowledgments)&#10;- [ Inspiration](#-inspiration)&#10;- [ Support](#-support)&#10;&#10;## ✨ Features&#10;&#10;-  **Seamless Java Version Switching** - Switch between different Java versions instantly&#10;-  **Zero Dependencies** - Runs as a native executable without requiring JVM installation&#10;-  **Cross-Platform Support** - Native binaries for Windows, Linux, and macOS&#10;- ⚡ **Lightning Fast** - Built with GraalVM Native Image for optimal performance&#10;-  **Simple CLI** - Intuitive command-line interface powered by PicoCLI&#10;-  **Developer Focused** - Designed to streamline Java development workflows&#10;&#10;##  Quick Start&#10;&#10;### Installation&#10;&#10;#### Windows&#10;```powershell&#10;# Download and run the installer&#10;.\JavaWizard-Native-Setup-1.0.0.exe&#10;```&#10;&#10;#### Linux/macOS&#10;```bash&#10;# Download the binary and make it executable&#10;chmod +x xwizard&#10;sudo mv xwizard /usr/local/bin/&#10;```&#10;&#10;### Basic Usage&#10;&#10;```bash&#10;# List available Java versions&#10;xwizard java list&#10;&#10;# Install a specific Java version&#10;xwizard java install 21&#10;&#10;# Set global Java version&#10;xwizard java global 21&#10;&#10;# Show current Java version&#10;xwizard java version&#10;&#10;# Manage PATH environment&#10;xwizard path show&#10;```&#10;&#10;##  Documentation&#10;&#10;### Commands&#10;&#10;| Command | Description |&#10;|---------|-------------|&#10;| `xwizard java list` | List all available Java versions |&#10;| `xwizard java install &lt;version&gt;` | Install a specific Java version |&#10;| `xwizard java global &lt;version&gt;` | Set global Java version |&#10;| `xwizard java version` | Show current active Java version |&#10;| `xwizard path show` | Display current PATH configuration |&#10;| `xwizard help` | Show help information |&#10;&#10;### Examples&#10;&#10;```bash&#10;# Install Java 17 and 21&#10;xwizard java install 17&#10;xwizard java install 21&#10;&#10;# Switch to Java 17 globally&#10;xwizard java global 17&#10;&#10;# Verify the switch&#10;java -version&#10;```&#10;&#10;## ️ Development&#10;&#10;### Prerequisites for Building&#10;&#10;- **JDK 21** or higher&#10;- **GraalVM Native Image** (for native compilation)&#10;- **Gradle 8+**&#10;&#10;### Building from Source&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/yourusername/xwizard.git&#10;cd xwizard&#10;&#10;# Build the JAR&#10;./gradlew build&#10;&#10;# Create native executable (requires GraalVM)&#10;./gradlew nativeCompile&#10;```&#10;&#10;### Project Structure&#10;&#10;```&#10;src/&#10;├── main/java/com/amankrmj/xwizard/&#10;│   ├── Main.java                    # Application entry point&#10;│   ├── commands/&#10;│   │   └── PathCommand.java         # PATH management commands&#10;│   └── java/&#10;│       ├── InstallJavaVersionCommand.java&#10;│       ├── JavaVersionManagerCommand.java&#10;│       ├── NativeCompilerCommand.java&#10;│       └── SetGlobalVersion.java&#10;└── main/resources/META-INF/native-image/&#10;    ├── proxy-config.json            # GraalVM proxy configuration&#10;    ├── reflect-config.json          # GraalVM reflection configuration&#10;    └── resource-config.json         # GraalVM resource configuration&#10;```&#10;&#10;### Technology Stack&#10;&#10;- **☕ Java 21** - Modern Java with latest features&#10;- **️ PicoCLI** - Powerful command-line interface framework&#10;- **⚡ GraalVM Native Image** - Ahead-of-time compilation for native executables&#10;- **️ Gradle** - Build automation and dependency management&#10;&#10;##  Contributing&#10;&#10;We welcome contributions from the community! Whether you're fixing bugs, adding new features, or improving documentation, your help is appreciated.&#10;&#10;### How to Contribute&#10;&#10;1. **Fork the repository**&#10;   ```bash&#10;   git fork https://github.com/yourusername/xwizard.git&#10;   ```&#10;&#10;2. **Create a feature branch**&#10;   ```bash&#10;   git checkout -b feature/amazing-feature&#10;   ```&#10;&#10;3. **Make your changes**&#10;   - Follow the existing code style&#10;   - Add tests for new functionality&#10;   - Update documentation as needed&#10;&#10;4. **Test your changes**&#10;   ```bash&#10;   ./gradlew test&#10;   ./gradlew nativeCompile  # Test native compilation&#10;   ```&#10;&#10;5. **Commit your changes**&#10;   ```bash&#10;   git commit -m &quot;Add amazing feature&quot;&#10;   ```&#10;&#10;6. **Push and create a Pull Request**&#10;   ```bash&#10;   git push origin feature/amazing-feature&#10;   ```&#10;&#10;### Development Guidelines&#10;&#10;- **Code Style**: Follow Java conventions and maintain consistency&#10;- **Testing**: Ensure all new features have appropriate tests&#10;- **Documentation**: Update README and inline documentation&#10;- **Native Compatibility**: Test native compilation on target platforms&#10;&#10;### Areas We Need Help With&#10;&#10;-  **Linux Distribution Support** - Package managers integration&#10;-  **macOS Optimization** - Native Apple Silicon support&#10;-  **Testing Framework** - Comprehensive test coverage&#10;-  **Documentation** - User guides and tutorials&#10;-  **Internationalization** - Multi-language support&#10;&#10;##  Roadmap&#10;&#10;- [ ] **v1.1.0**: Support for additional JVM distributions (Temurin, Corretto, etc.)&#10;- [ ] **v1.2.0**: Project-specific Java version management (.java-version files)&#10;- [ ] **v1.3.0**: Integration with popular build tools (Maven, Gradle)&#10;- [ ] **v2.0.0**: Support for other programming languages (Python, Node.js, Go, Rust)&#10;&#10;##  Current Sprint&#10;&#10;We're actively working on the following features and improvements:&#10;&#10;###  Web Interface Development&#10;- Building a visual web interface for interactive Java version management&#10;- Creating user-friendly GUI for non-CLI users&#10;- Developing real-time status dashboards and configuration panels&#10;&#10;###  Core Testing &amp; Validation&#10;- Comprehensive testing of Java version management functionality&#10;- Validating installation, switching, and global version settings&#10;- Performance benchmarking of native executables across platforms&#10;&#10;###  Native Build Optimization&#10;- Refining GraalVM native compilation process&#10;- Optimizing binary size and startup performance&#10;- Ensuring consistent behavior across Windows, Linux, and macOS&#10;&#10;*Stay tuned for updates as we enhance XWizard's capabilities!*&#10;&#10;##  License&#10;&#10;This project is licensed under the GNU Affero General Public License v3.0 (GNU AGPLv3) - see the [LICENSE](LICENSE) file for details.&#10;&#10;### License Summary&#10;&#10;The **CC BY-NC 4.0** license allows you to:&#10;&#10;- ✅ **Share**: Copy and redistribute the material in any medium or format&#10;- ✅ **Adapt**: Remix, transform, and build upon the material&#10;- ✅ **Attribution**: You must give appropriate credit and indicate if changes were made&#10;- ❌ **NonCommercial**: You may not use the material for commercial purposes&#10;- ✅ **No Additional Restrictions**: The licensor cannot revoke these freedoms as long as you follow the license terms&#10;&#10;This license ensures that XWizard remains freely available for educational, research, and personal use while protecting against unauthorized commercial exploitation.&#10;&#10;##  Acknowledgments&#10;&#10;- **Oracle JDK 21** - For providing the modern Java platform&#10;- **GraalVM** - For enabling native compilation and ahead-of-time optimization&#10;- **PicoCLI** - For the excellent command-line interface framework&#10;&#10;##  Inspiration&#10;&#10;XWizard was inspired by excellent version management tools in the developer ecosystem:&#10;&#10;- **[SDKMAN!](https://sdkman.io/)** - The Software Development Kit Manager for managing parallel versions of multiple SDKs&#10;- **[pyenv](https://github.com/pyenv/pyenv)** - Simple Python version management that pioneered the local/global version concept&#10;&#10;These tools demonstrated the power of seamless version switching and inspired us to create a native, dependency-free solution for Java developers.&#10;&#10;##  Support&#10;&#10;-  **Bug Reports**: [Create an issue](https://github.com/yourusername/xwizard/issues/new?template=bug_report.md)&#10;-  **Feature Requests**: [Create an issue](https://github.com/yourusername/xwizard/issues/new?template=feature_request.md)&#10;-  **Discussions**: [Join our discussions](https://github.com/yourusername/xwizard/discussions)&#10;&#10;---&#10;&#10;&lt;div align=&quot;center&quot;&gt;&#10;&#10;**Made with ❤️ by the XWizard**&#10;&#10;[Website](https://xwizard.dev) • [Documentation](https://docs.xwizard.dev) • [Twitter](https://twitter.com/xwizard_dev)&#10;&#10;&lt;/div&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    id(&quot;org.graalvm.buildtools.native&quot;) version &quot;0.10.1&quot;&#10;}&#10;&#10;group = &quot;com.amankrmj.javawizard&quot;&#10;version = &quot;1.0.0&quot;&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation(&quot;info.picocli:picocli:4.7.5&quot;)&#10;    annotationProcessor(&quot;info.picocli:picocli-codegen:4.7.5&quot;)&#10;    &#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.mockito:mockito-core:5.5.0&quot;)&#10;    testImplementation(&quot;org.mockito:mockito-junit-jupiter:5.5.0&quot;)&#10;}&#10;&#10;application {&#10;    mainClass.set(&quot;com.amankrmj.javawizard.JavaWizardApplication&quot;)&#10;    applicationName = &quot;javawizard&quot;&#10;}&#10;&#10;graalvmNative {&#10;    binaries {&#10;        named(&quot;main&quot;) {&#10;            imageName.set(&quot;javawizard&quot;)&#10;            mainClass.set(&quot;com.amankrmj.javawizard.JavaWizardApplication&quot;)&#10;            useFatJar.set(true)&#10;            &#10;            buildArgs.addAll(&#10;                &quot;--no-fallback&quot;,&#10;                &quot;--report-unsupported-elements-at-runtime&quot;,&#10;                &quot;-H:+ReportExceptionStackTraces&quot;,&#10;                &quot;-H:-CheckToolchain&quot;,&#10;                &quot;-H:+UnlockExperimentalVMOptions&quot;&#10;            )&#10;            // For PicoCLI&#10;            buildArgs.add(&quot;-H:ReflectionConfigurationFiles=${project.layout.buildDirectory.get()}/resources/main/META-INF/native-image/reflect-config.json&quot;)&#10;        }&#10;    }&#10;    &#10;    agent {&#10;        defaultMode.set(&quot;standard&quot;)&#10;        builtinCallerFilter.set(true)&#10;        builtinHeuristicFilter.set(true)&#10;        enableExperimentalPredefinedClasses.set(false)&#10;        trackReflectionMetadata.set(true)&#10;    }&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;    testLogging {&#10;        events(&quot;passed&quot;, &quot;skipped&quot;, &quot;failed&quot;)&#10;    }&#10;}&#10;&#10;java {&#10;    sourceCompatibility = JavaVersion.VERSION_21&#10;    targetCompatibility = JavaVersion.VERSION_21&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(21))&#10;    }&#10;}&#10;&#10;// Distribution tasks&#10;tasks.register&lt;Copy&gt;(&quot;nativeInstallDist&quot;) {&#10;    dependsOn(&quot;nativeCompile&quot;)&#10;    group = &quot;distribution&quot;&#10;    description = &quot;Creates a distribution with the native executable&quot;&#10;    &#10;    from(&quot;build/native/nativeCompile&quot;) {&#10;        include(&quot;javawizard.exe&quot;)&#10;        into(&quot;bin&quot;)&#10;    }&#10;    &#10;    into(&quot;build/install/javawizard-native&quot;)&#10;}&#10;&#10;// Custom task to create installer with Inno Setup&#10;tasks.register&lt;Exec&gt;(&quot;createInstaller&quot;) {&#10;    dependsOn(&quot;nativeCompile&quot;)&#10;    group = &quot;distribution&quot;&#10;    description = &quot;Create Windows installer using Inno Setup&quot;&#10;    &#10;    doFirst {&#10;        println(&quot;Creating installer with Inno Setup...&quot;)&#10;    }&#10;    &#10;    commandLine(&quot;cmd&quot;, &quot;/c&quot;, &quot;\&quot;C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe\&quot;&quot;, &quot;installer/javawizard-installer.iss&quot;)&#10;    workingDir(projectDir)&#10;    &#10;    doLast {&#10;        println(&quot;Installer created successfully!&quot;)&#10;    }&#10;}&#10;&#10;// Optionally make nativeCompile automatically trigger installer creation&#10;tasks.named(&quot;nativeCompile&quot;) {&#10;    finalizedBy(&quot;createInstaller&quot;)&#10;}&#10;&#10;// Code quality and documentation&#10;tasks.register&lt;Javadoc&gt;(&quot;javadocJar&quot;) {&#10;    group = &quot;documentation&quot;&#10;    description = &quot;Generate Javadoc JAR&quot;&#10;}&#10;&#10;tasks.register&lt;Jar&gt;(&quot;sourcesJar&quot;) {&#10;    group = &quot;documentation&quot;&#10;    description = &quot;Generate sources JAR&quot;&#10;    archiveClassifier.set(&quot;sources&quot;)&#10;    from(sourceSets.main.get().allSource)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id(&quot;java&quot;)&#10;    id(&quot;application&quot;)&#10;    id(&quot;org.graalvm.buildtools.native&quot;) version &quot;0.10.1&quot;&#10;}&#10;&#10;group = &quot;com.amankrmj.javawizard&quot;&#10;version = &quot;1.0.0&quot;&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation(&quot;info.picocli:picocli:4.7.5&quot;)&#10;    annotationProcessor(&quot;info.picocli:picocli-codegen:4.7.5&quot;)&#10;    &#10;    testImplementation(platform(&quot;org.junit:junit-bom:5.10.0&quot;))&#10;    testImplementation(&quot;org.junit.jupiter:junit-jupiter&quot;)&#10;    testImplementation(&quot;org.mockito:mockito-core:5.5.0&quot;)&#10;    testImplementation(&quot;org.mockito:mockito-junit-jupiter:5.5.0&quot;)&#10;}&#10;&#10;application {&#10;    mainClass.set(&quot;com.amankrmj.xwizard.Main&quot;)&#10;    applicationName = &quot;javawizard&quot;&#10;}&#10;&#10;graalvmNative {&#10;    binaries {&#10;        named(&quot;main&quot;) {&#10;            imageName.set(&quot;javawizard&quot;)&#10;            mainClass.set(&quot;com.amankrmj.xwizard.Main&quot;)&#10;            useFatJar.set(true)&#10;            &#10;            buildArgs.addAll(&#10;                &quot;--no-fallback&quot;,&#10;                &quot;--report-unsupported-elements-at-runtime&quot;,&#10;                &quot;-H:+ReportExceptionStackTraces&quot;,&#10;                &quot;-H:-CheckToolchain&quot;,&#10;                &quot;-H:+UnlockExperimentalVMOptions&quot;&#10;            )&#10;            // For PicoCLI&#10;            buildArgs.add(&quot;-H:ReflectionConfigurationFiles=${project.layout.buildDirectory.get()}/resources/main/META-INF/native-image/reflect-config.json&quot;)&#10;        }&#10;    }&#10;    &#10;    agent {&#10;        defaultMode.set(&quot;standard&quot;)&#10;        builtinCallerFilter.set(true)&#10;        builtinHeuristicFilter.set(true)&#10;        enableExperimentalPredefinedClasses.set(false)&#10;        trackReflectionMetadata.set(true)&#10;    }&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;    testLogging {&#10;        events(&quot;passed&quot;, &quot;skipped&quot;, &quot;failed&quot;)&#10;    }&#10;}&#10;&#10;java {&#10;    sourceCompatibility = JavaVersion.VERSION_21&#10;    targetCompatibility = JavaVersion.VERSION_21&#10;    toolchain {&#10;        languageVersion.set(JavaLanguageVersion.of(21))&#10;    }&#10;}&#10;&#10;// Distribution tasks&#10;tasks.register&lt;Copy&gt;(&quot;nativeInstallDist&quot;) {&#10;    dependsOn(&quot;nativeCompile&quot;)&#10;    group = &quot;distribution&quot;&#10;    description = &quot;Creates a distribution with the native executable&quot;&#10;    &#10;    from(&quot;build/native/nativeCompile&quot;) {&#10;        include(&quot;javawizard.exe&quot;)&#10;        into(&quot;bin&quot;)&#10;    }&#10;    &#10;    into(&quot;build/install/javawizard-native&quot;)&#10;}&#10;&#10;// Custom task to create installer with Inno Setup&#10;tasks.register&lt;Exec&gt;(&quot;createInstaller&quot;) {&#10;    dependsOn(&quot;nativeCompile&quot;)&#10;    group = &quot;distribution&quot;&#10;    description = &quot;Create Windows installer using Inno Setup&quot;&#10;    &#10;    doFirst {&#10;        println(&quot;Creating installer with Inno Setup...&quot;)&#10;    }&#10;    &#10;    commandLine(&quot;cmd&quot;, &quot;/c&quot;, &quot;\&quot;C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe\&quot;&quot;, &quot;installer/javawizard-installer.iss&quot;)&#10;    workingDir(projectDir)&#10;    &#10;    doLast {&#10;        println(&quot;Installer created successfully!&quot;)&#10;    }&#10;}&#10;&#10;// Optionally make nativeCompile automatically trigger installer creation&#10;tasks.named(&quot;nativeCompile&quot;) {&#10;    finalizedBy(&quot;createInstaller&quot;)&#10;}&#10;&#10;// Code quality and documentation&#10;tasks.register&lt;Javadoc&gt;(&quot;javadocJar&quot;) {&#10;    group = &quot;documentation&quot;&#10;    description = &quot;Generate Javadoc JAR&quot;&#10;}&#10;&#10;tasks.register&lt;Jar&gt;(&quot;sourcesJar&quot;) {&#10;    group = &quot;documentation&quot;&#10;    description = &quot;Generate sources JAR&quot;&#10;    archiveClassifier.set(&quot;sources&quot;)&#10;    from(sourceSets.main.get().allSource)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/JavaWizardApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/JavaWizardApplication.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import com.amankrmj.javawizard.commands.PathCommand;&#10;import com.amankrmj.javawizard.commands.java.JavaVersionManagerCommand;&#10;import com.amankrmj.javawizard.commands.native_.NativeCompilerCommand;&#10;&#10;@Command(name = &quot;javawizard&quot;,&#10;         mixinStandardHelpOptions = true,&#10;         version = &quot;1.0.0&quot;,&#10;         description = &quot;JavaWizard - Complete Java Development Environment Manager&quot;,&#10;         subcommands = {&#10;             PathCommand.class,&#10;             JavaVersionManagerCommand.class,&#10;             NativeCompilerCommand.class&#10;         })&#10;public class JavaWizardApplication implements Runnable {&#10;&#10;    @Option(names = {&quot;-v&quot;, &quot;--verbose&quot;}, description = &quot;Enable verbose output&quot;)&#10;    private boolean verbose = false;&#10;&#10;    public boolean isVerbose() {&#10;        return verbose;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;JavaWizard - Complete Java Development Environment Manager&quot;);&#10;        System.out.println(&quot;Use --help for options or try these commands:&quot;);&#10;        System.out.println(&quot;  path     - Manage environment PATH variables&quot;);&#10;        System.out.println(&quot;  java     - Manage Java versions and installations&quot;);&#10;        System.out.println(&quot;  native   - Manage native compilation and cross-platform builds&quot;);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        CommandLine cmd = new CommandLine(new JavaWizardApplication());&#10;        int exitCode = cmd.execute(args);&#10;        System.exit(exitCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/PathCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/PathCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;path&quot;,&#10;         description = &quot;Manage environment PATH variables&quot;,&#10;         subcommands = {&#10;             PathCommand.AddCommand.class,&#10;             PathCommand.RemoveCommand.class,&#10;             PathCommand.ListCommand.class&#10;         })&#10;public class PathCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Use 'path --help' to see available subcommands:&quot;);&#10;        System.out.println(&quot;  add    - Add directory to PATH&quot;);&#10;        System.out.println(&quot;  remove - Remove directory from PATH&quot;);&#10;        System.out.println(&quot;  list   - List current PATH entries&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;add&quot;, description = &quot;Add a directory to user PATH environment variable&quot;)&#10;    static class AddCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to add to PATH&quot;)&#10;        private String pathToAdd;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Add to system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Add even if path already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                // Check if path already exists&#10;                if (!force &amp;&amp; isPathAlreadyInPATH(currentPath, pathToAdd)) {&#10;                    System.out.println(&quot;Path already exists in &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                    return 0;&#10;                }&#10;                &#10;                // Add to PATH&#10;                String newPath = currentPath.isEmpty() ? pathToAdd : currentPath + &quot;;&quot; + pathToAdd;&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully added to &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error adding to PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;remove&quot;, description = &quot;Remove a directory from user PATH environment variable&quot;)&#10;    static class RemoveCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to remove from PATH&quot;)&#10;        private String pathToRemove;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Remove from system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                if (!isPathAlreadyInPATH(currentPath, pathToRemove)) {&#10;                    System.out.println(&quot;Path not found in &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                    return 0;&#10;                }&#10;                &#10;                // Remove from PATH&#10;                String newPath = removePathFromPATH(currentPath, pathToRemove);&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully removed from &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error removing from PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List current PATH entries&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Show system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show both user and system PATH&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== USER PATH ===&quot;);&#10;                    listPath(&quot;USER&quot;);&#10;                    System.out.println(&quot;\n=== SYSTEM PATH ===&quot;);&#10;                    listPath(&quot;SYSTEM&quot;);&#10;                } else {&#10;                    String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                    System.out.println(&quot;=== &quot; + scope + &quot; PATH ===&quot;);&#10;                    listPath(scope);&#10;                }&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listPath(String scope) throws IOException, InterruptedException {&#10;            String currentPath = getCurrentPath(scope);&#10;            if (currentPath.isEmpty()) {&#10;                System.out.println(&quot;No &quot; + scope + &quot; PATH entries found.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String[] paths = currentPath.split(&quot;;&quot;);&#10;            for (int i = 0; i &lt; paths.length; i++) {&#10;                String path = paths[i].trim();&#10;                if (!path.isEmpty()) {&#10;                    System.out.println((i + 1) + &quot;. &quot; + path);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static String getCurrentPath(String scope) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, hive + &quot;\\&quot; + key, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        &#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        // Parse reg output to get PATH value&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    return parts[2].trim();&#10;                }&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;    &#10;    private static void setPathVariable(String scope, String newPath) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, hive + &quot;\\&quot; + key, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update registry: &quot; + error);&#10;        }&#10;        &#10;        // Broadcast environment change&#10;        broadcastEnvironmentChange();&#10;    }&#10;    &#10;    private static boolean isPathAlreadyInPATH(String currentPath, String pathToCheck) {&#10;        if (currentPath.isEmpty()) return false;&#10;        &#10;        List&lt;String&gt; paths = Arrays.asList(currentPath.toLowerCase().split(&quot;;&quot;));&#10;        return paths.contains(pathToCheck.toLowerCase().trim());&#10;    }&#10;    &#10;    private static String removePathFromPATH(String currentPath, String pathToRemove) {&#10;        String[] paths = currentPath.split(&quot;;&quot;);&#10;        StringBuilder newPath = new StringBuilder();&#10;        &#10;        for (String path : paths) {&#10;            String trimmedPath = path.trim();&#10;            if (!trimmedPath.isEmpty() &amp;&amp; !trimmedPath.equalsIgnoreCase(pathToRemove.trim())) {&#10;                if (newPath.length() &gt; 0) {&#10;                    newPath.append(&quot;;&quot;);&#10;                }&#10;                newPath.append(trimmedPath);&#10;            }&#10;        }&#10;        &#10;        return newPath.toString();&#10;    }&#10;    &#10;    private static void broadcastEnvironmentChange() {&#10;        try {&#10;            // Notify system of environment changes&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;powershell&quot;, &quot;-Command&quot;, &#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', [System.Guid]::NewGuid().ToString(), 'User'); &quot; +&#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', $null, 'User')&quot;);&#10;            Process process = pb.start();&#10;            process.waitFor();&#10;        } catch (Exception e) {&#10;            // Silent fail - environment change broadcast is optional&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/java/JavaVersionManagerCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/java/JavaVersionManagerCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands.java;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;import java.util.stream.Collectors;&#10;&#10;@Command(name = &quot;java&quot;,&#10;         description = &quot;Manage Java versions and installations&quot;,&#10;         subcommands = {&#10;             JavaVersionManagerCommand.ListCommand.class,&#10;             JavaVersionManagerCommand.InstallCommand.class,&#10;             JavaVersionManagerCommand.UseCommand.class,&#10;             JavaVersionManagerCommand.CurrentCommand.class,&#10;             JavaVersionManagerCommand.WhichCommand.class&#10;         })&#10;public class JavaVersionManagerCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Java Version Manager - Use 'java --help' for options:&quot;);&#10;        System.out.println(&quot;  list     - List installed Java versions&quot;);&#10;        System.out.println(&quot;  install  - Install a specific Java version&quot;);&#10;        System.out.println(&quot;  use      - Switch to a specific Java version&quot;);&#10;        System.out.println(&quot;  current  - Show current active Java version&quot;);&#10;        System.out.println(&quot;  which    - Show path to current Java installation&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List all installed Java versions&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show all detected Java installations&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== All Detected Java Installations ===&quot;);&#10;                    findAllJavaInstallations();&#10;                } else {&#10;                    System.out.println(&quot;=== Managed Java Versions ===&quot;);&#10;                    listManagedVersions();&#10;                }&#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing Java versions: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listManagedVersions() throws IOException {&#10;            Path javaVersionsDir = getJavaVersionsDirectory();&#10;            if (!Files.exists(javaVersionsDir)) {&#10;                System.out.println(&quot;No managed Java versions found.&quot;);&#10;                System.out.println(&quot;Use 'javawizard java install &lt;version&gt;' to install Java versions.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String currentVersion = getCurrentJavaVersion();&#10;            &#10;            Files.list(javaVersionsDir)&#10;                .filter(Files::isDirectory)&#10;                .map(path -&gt; path.getFileName().toString())&#10;                .sorted()&#10;                .forEach(version -&gt; {&#10;                    String marker = version.equals(currentVersion) ? &quot; (current)&quot; : &quot;&quot;;&#10;                    System.out.println(&quot;  &quot; + version + marker);&#10;                });&#10;        }&#10;        &#10;        private void findAllJavaInstallations() {&#10;            // Common Java installation paths&#10;            String[] commonPaths = {&#10;                &quot;C:\\Program Files\\Java&quot;,&#10;                &quot;C:\\Program Files (x86)\\Java&quot;,&#10;                &quot;C:\\Program Files\\Eclipse Adoptium&quot;,&#10;                &quot;C:\\Program Files\\Microsoft&quot;,&#10;                System.getProperty(&quot;user.home&quot;) + &quot;\\.jdks&quot;&#10;            };&#10;            &#10;            System.out.println(&quot;Scanning common installation directories...&quot;);&#10;            &#10;            for (String basePath : commonPaths) {&#10;                File baseDir = new File(basePath);&#10;                if (baseDir.exists() &amp;&amp; baseDir.isDirectory()) {&#10;                    System.out.println(&quot;\n&quot; + basePath + &quot;:&quot;);&#10;                    File[] javaInstalls = baseDir.listFiles(File::isDirectory);&#10;                    if (javaInstalls != null) {&#10;                        for (File install : javaInstalls) {&#10;                            String version = detectJavaVersion(install);&#10;                            System.out.println(&quot;  &quot; + install.getName() + &quot; &quot; + version);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Also check JAVA_HOME&#10;            String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;            if (javaHome != null) {&#10;                System.out.println(&quot;\nJAVA_HOME: &quot; + javaHome);&#10;                System.out.println(&quot;  Version: &quot; + detectJavaVersion(new File(javaHome)));&#10;            }&#10;        }&#10;        &#10;        private String detectJavaVersion(File javaHome) {&#10;            try {&#10;                File javaBin = new File(javaHome, &quot;bin/java.exe&quot;);&#10;                if (!javaBin.exists()) {&#10;                    javaBin = new File(javaHome, &quot;bin/java&quot;);&#10;                }&#10;                &#10;                if (javaBin.exists()) {&#10;                    ProcessBuilder pb = new ProcessBuilder(javaBin.getAbsolutePath(), &quot;-version&quot;);&#10;                    Process process = pb.start();&#10;                    String output = new String(process.getErrorStream().readAllBytes());&#10;                    process.waitFor();&#10;                    &#10;                    // Parse version from output&#10;                    String[] lines = output.split(&quot;\n&quot;);&#10;                    if (lines.length &gt; 0) {&#10;                        return lines[0].replaceAll(&quot;.*\&quot;(.*)\&quot;.*&quot;, &quot;($1)&quot;);&#10;                    }&#10;                }&#10;                return &quot;(unknown)&quot;;&#10;            } catch (Exception e) {&#10;                return &quot;(error: &quot; + e.getMessage() + &quot;)&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;install&quot;, description = &quot;Install a specific Java version&quot;)&#10;    static class InstallCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Java version to install (e.g., 17, 21, 11-graalvm)&quot;)&#10;        private String version;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Force reinstall if already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            System.out.println(&quot;Installing Java &quot; + version + &quot;...&quot;);&#10;            &#10;            if (version.contains(&quot;graalvm&quot;)) {&#10;                return installGraalVM();&#10;            } else {&#10;                return installOpenJDK();&#10;            }&#10;        }&#10;        &#10;        private Integer installGraalVM() {&#10;            System.out.println(&quot;GraalVM Installation Guide:&quot;);&#10;            System.out.println(&quot;1. Download GraalVM from: https://www.graalvm.org/downloads/&quot;);&#10;            System.out.println(&quot;2. Choose the appropriate version for your platform:&quot;);&#10;            System.out.println(&quot;   - Windows: graalvm-community-jdk-&lt;version&gt;_windows-x64_bin.zip&quot;);&#10;            System.out.println(&quot;   - macOS: graalvm-community-jdk-&lt;version&gt;_macos-x64_bin.tar.gz&quot;);&#10;            System.out.println(&quot;   - Linux: graalvm-community-jdk-&lt;version&gt;_linux-x64_bin.tar.gz&quot;);&#10;            System.out.println(&quot;3. Extract to: &quot; + getJavaVersionsDirectory().resolve(&quot;graalvm-&quot; + version.replace(&quot;-graalvm&quot;, &quot;&quot;)));&#10;            System.out.println(&quot;4. Run: javawizard java use graalvm-&quot; + version.replace(&quot;-graalvm&quot;, &quot;&quot;));&#10;            return 0;&#10;        }&#10;        &#10;        private Integer installOpenJDK() {&#10;            System.out.println(&quot;OpenJDK Installation Guide:&quot;);&#10;            System.out.println(&quot;1. Download from Eclipse Adoptium: https://adoptium.net/&quot;);&#10;            System.out.println(&quot;2. Choose version &quot; + version + &quot; for your platform&quot;);&#10;            System.out.println(&quot;3. Extract to: &quot; + getJavaVersionsDirectory().resolve(&quot;jdk-&quot; + version));&#10;            System.out.println(&quot;4. Run: javawizard java use jdk-&quot; + version);&#10;            System.out.println();&#10;            System.out.println(&quot;Alternative - Use package managers:&quot;);&#10;            System.out.println(&quot;Windows (winget): winget install Microsoft.OpenJDK.&quot; + version);&#10;            System.out.println(&quot;macOS (brew): brew install openjdk@&quot; + version);&#10;            System.out.println(&quot;Linux (apt): sudo apt install openjdk-&quot; + version + &quot;-jdk&quot;);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;use&quot;, description = &quot;Switch to a specific Java version&quot;)&#10;    static class UseCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Java version to use&quot;)&#10;        private String version;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                Path javaVersionsDir = getJavaVersionsDirectory();&#10;                Path versionPath = javaVersionsDir.resolve(version);&#10;                &#10;                if (!Files.exists(versionPath)) {&#10;                    System.err.println(&quot;Java version not found: &quot; + version);&#10;                    System.err.println(&quot;Available versions:&quot;);&#10;                    if (Files.exists(javaVersionsDir)) {&#10;                        Files.list(javaVersionsDir)&#10;                            .filter(Files::isDirectory)&#10;                            .map(path -&gt; path.getFileName().toString())&#10;                            .forEach(v -&gt; System.err.println(&quot;  &quot; + v));&#10;                    }&#10;                    return 1;&#10;                }&#10;                &#10;                // Set JAVA_HOME&#10;                setJavaHome(versionPath.toString());&#10;                &#10;                // Update PATH&#10;                updatePathForJava(versionPath.resolve(&quot;bin&quot;).toString());&#10;                &#10;                System.out.println(&quot;Switched to Java version: &quot; + version);&#10;                System.out.println(&quot;JAVA_HOME: &quot; + versionPath);&#10;                System.out.println(&quot;Note: Restart your terminal to see the changes.&quot;);&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error switching Java version: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;current&quot;, description = &quot;Show current active Java version&quot;)&#10;    static class CurrentCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;                if (javaHome == null) {&#10;                    System.out.println(&quot;JAVA_HOME not set&quot;);&#10;                } else {&#10;                    System.out.println(&quot;JAVA_HOME: &quot; + javaHome);&#10;                }&#10;                &#10;                // Try to get version from java command&#10;                ProcessBuilder pb = new ProcessBuilder(&quot;java&quot;, &quot;-version&quot;);&#10;                Process process = pb.start();&#10;                String output = new String(process.getErrorStream().readAllBytes());&#10;                int exitCode = process.waitFor();&#10;                &#10;                if (exitCode == 0) {&#10;                    System.out.println(&quot;Active Java version:&quot;);&#10;                    System.out.println(output.trim());&#10;                } else {&#10;                    System.out.println(&quot;No Java found in PATH&quot;);&#10;                }&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error getting current Java version: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;which&quot;, description = &quot;Show path to current Java installation&quot;)&#10;    static class WhichCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                ProcessBuilder pb = new ProcessBuilder(&quot;where&quot;, &quot;java&quot;);&#10;                Process process = pb.start();&#10;                String output = new String(process.getInputStream().readAllBytes());&#10;                int exitCode = process.waitFor();&#10;                &#10;                if (exitCode == 0) {&#10;                    System.out.println(&quot;Java executable locations:&quot;);&#10;                    System.out.println(output.trim());&#10;                } else {&#10;                    System.out.println(&quot;Java not found in PATH&quot;);&#10;                }&#10;                &#10;                return 0;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error finding Java: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static Path getJavaVersionsDirectory() {&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#10;        return Paths.get(userHome, &quot;.javawizard&quot;, &quot;java-versions&quot;);&#10;    }&#10;    &#10;    private static String getCurrentJavaVersion() {&#10;        String javaHome = System.getenv(&quot;JAVA_HOME&quot;);&#10;        if (javaHome == null) return null;&#10;        &#10;        Path javaVersionsDir = getJavaVersionsDirectory();&#10;        Path javaHomePath = Paths.get(javaHome);&#10;        &#10;        if (javaHomePath.startsWith(javaVersionsDir)) {&#10;            return javaVersionsDir.relativize(javaHomePath).toString();&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    private static void setJavaHome(String javaHome) throws IOException, InterruptedException {&#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, &quot;HKCU\\Environment&quot;, &#10;            &quot;/v&quot;, &quot;JAVA_HOME&quot;, &quot;/t&quot;, &quot;REG_SZ&quot;, &quot;/d&quot;, javaHome, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to set JAVA_HOME: &quot; + error);&#10;        }&#10;    }&#10;    &#10;    private static void updatePathForJava(String javaBinPath) throws IOException, InterruptedException {&#10;        // Get current user PATH&#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, &quot;HKCU\\Environment&quot;, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        String currentPath = &quot;&quot;;&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    currentPath = parts[2].trim();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Remove any existing Java paths and add new one at the beginning&#10;        String[] pathParts = currentPath.split(&quot;;&quot;);&#10;        String newPath = javaBinPath + &quot;;&quot; + Arrays.stream(pathParts)&#10;            .filter(part -&gt; !part.toLowerCase().contains(&quot;java&quot;) || part.trim().isEmpty())&#10;            .collect(Collectors.joining(&quot;;&quot;));&#10;        &#10;        // Set new PATH&#10;        pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, &quot;HKCU\\Environment&quot;, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update PATH: &quot; + error);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/native_/NativeCompilerCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/javawizard/commands/native_/NativeCompilerCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.javawizard.commands.native_;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;native&quot;,&#10;         description = &quot;Manage native compilation tools and create platform-specific executables&quot;,&#10;         subcommands = {&#10;             NativeCompilerCommand.InfoCommand.class,&#10;             NativeCompilerCommand.InstallCommand.class,&#10;             NativeCompilerCommand.BuildCommand.class,&#10;             NativeCompilerCommand.PackageCommand.class&#10;         })&#10;public class NativeCompilerCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Native Compilation Manager - Create standalone executables&quot;);&#10;        System.out.println(&quot;Available commands:&quot;);&#10;        System.out.println(&quot;  info     - Show native compilation options for current platform&quot;);&#10;        System.out.println(&quot;  install  - Install native compilation tools&quot;);&#10;        System.out.println(&quot;  build    - Build native executable&quot;);&#10;        System.out.println(&quot;  package  - Create platform-specific installers&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;info&quot;, description = &quot;Show native compilation options for current platform&quot;)&#10;    static class InfoCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            String arch = System.getProperty(&quot;os.arch&quot;);&#10;            &#10;            System.out.println(&quot;=== Native Compilation Options ===&quot;);&#10;            System.out.println(&quot;Platform: &quot; + os + &quot; (&quot; + arch + &quot;)&quot;);&#10;            System.out.println();&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                showWindowsOptions();&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                showMacOptions();&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                showLinuxOptions();&#10;            } else {&#10;                System.out.println(&quot;Unsupported platform: &quot; + os);&#10;                return 1;&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private void showWindowsOptions() {&#10;            System.out.println(&quot; WINDOWS NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates true native executables (.exe)&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;   ✅ Fast startup, low memory usage&quot;);&#10;            System.out.println(&quot;    Install: Download from graalvm.org&quot;);&#10;            System.out.println(&quot;   ️  Requires: Visual Studio Build Tools&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;            System.out.println(&quot;    Creates: .exe installer with bundled JRE&quot;);&#10;            System.out.println(&quot;   ️  Command: jpackage --input ... --main-jar ...&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;3. Launch4j + Inno Setup&quot;);&#10;            System.out.println(&quot;   ⚠️  Requires JVM on target machine&quot;);&#10;            System.out.println(&quot;    Creates: .exe wrapper + installer&quot;);&#10;            System.out.println(&quot;    Smaller download, JVM dependency&quot;);&#10;        }&#10;        &#10;        private void showMacOptions() {&#10;            System.out.println(&quot; macOS NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates native Mach-O executables&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;    Install: brew install --cask graalvm/tap/graalvm-jdk21&quot;);&#10;            System.out.println(&quot;   ️  Requires: Xcode Command Line Tools&quot;);&#10;            System.out.println(&quot;    Supports: Intel &amp; Apple Silicon (M1/M2)&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;    Creates: .app bundles or .dmg installers&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;        }&#10;        &#10;        private void showLinuxOptions() {&#10;            System.out.println(&quot; LINUX NATIVE COMPILATION OPTIONS:&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;1. GraalVM Native Image (Recommended)&quot;);&#10;            System.out.println(&quot;   ✅ Creates native ELF executables&quot;);&#10;            System.out.println(&quot;   ✅ No JVM required at runtime&quot;);&#10;            System.out.println(&quot;    Install: sdk install java 21.0.1-graal (using SDKMAN)&quot;);&#10;            System.out.println(&quot;   ️  Requires: gcc, glibc-devel, zlib-devel&quot;);&#10;            System.out.println();&#10;            &#10;            System.out.println(&quot;2. jpackage (Java 14+)&quot;);&#10;            System.out.println(&quot;   ✅ Built into OpenJDK&quot;);&#10;            System.out.println(&quot;    Creates: .deb, .rpm packages or AppImage&quot;);&#10;            System.out.println(&quot;   ⚠️  Bundles JVM (larger size)&quot;);&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;install&quot;, description = &quot;Install native compilation tools for current platform&quot;)&#10;    static class InstallCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Tool to install: graalvm, build-tools, jpackage&quot;)&#10;        private String tool;&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            &#10;            switch (tool.toLowerCase()) {&#10;                case &quot;graalvm&quot;:&#10;                    return installGraalVM(os);&#10;                case &quot;build-tools&quot;:&#10;                    return installBuildTools(os);&#10;                case &quot;jpackage&quot;:&#10;                    return installJPackage(os);&#10;                default:&#10;                    System.err.println(&quot;Unknown tool: &quot; + tool);&#10;                    System.err.println(&quot;Available tools: graalvm, build-tools, jpackage&quot;);&#10;                    return 1;&#10;            }&#10;        }&#10;        &#10;        private Integer installGraalVM(String os) {&#10;            System.out.println(&quot;Installing GraalVM for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows GraalVM Installation:&quot;);&#10;                System.out.println(&quot;1. Download from: https://github.com/graalvm/graalvm-ce-builds/releases&quot;);&#10;                System.out.println(&quot;2. Or use Chocolatey: choco install graalvm&quot;);&#10;                System.out.println(&quot;3. Set JAVA_HOME and add to PATH&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS GraalVM Installation:&quot;);&#10;                System.out.println(&quot;brew install --cask graalvm/tap/graalvm-jdk21&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux GraalVM Installation:&quot;);&#10;                System.out.println(&quot;curl -s 'https://get.sdkman.io' | bash&quot;);&#10;                System.out.println(&quot;sdk install java 21.0.1-graal&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private Integer installBuildTools(String os) {&#10;            System.out.println(&quot;Installing build tools for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows Build Tools:&quot;);&#10;                System.out.println(&quot;Download Visual Studio Build Tools 2022&quot;);&#10;                System.out.println(&quot;Or Visual Studio Community with C++ workload&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS Build Tools:&quot;);&#10;                System.out.println(&quot;xcode-select --install&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux Build Tools:&quot;);&#10;                System.out.println(&quot;Ubuntu/Debian: sudo apt install build-essential zlib1g-dev&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;        &#10;        private Integer installJPackage(String os) {&#10;            System.out.println(&quot;jpackage is included with OpenJDK 14+&quot;);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;build&quot;, description = &quot;Build native executable using available tools&quot;)&#10;    static class BuildCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-t&quot;, &quot;--tool&quot;}, description = &quot;Tool to use: graalvm, jpackage&quot;)&#10;        private String tool = &quot;graalvm&quot;;&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            if (&quot;graalvm&quot;.equals(tool)) {&#10;                System.out.println(&quot;Building with GraalVM Native Image...&quot;);&#10;                System.out.println(&quot;Use: ./gradlew nativeCompile&quot;);&#10;            } else if (&quot;jpackage&quot;.equals(tool)) {&#10;                System.out.println(&quot;Building with jpackage...&quot;);&#10;                String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;                &#10;                if (os.contains(&quot;windows&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type exe --name JavaWizard&quot;);&#10;                } else if (os.contains(&quot;mac&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type dmg --name JavaWizard&quot;);&#10;                } else if (os.contains(&quot;linux&quot;)) {&#10;                    System.out.println(&quot;jpackage --input build/libs --main-jar javawizard-1.0.0.jar --main-class com.amankrmj.javawizard.JavaWizardApplication --type deb --name javawizard&quot;);&#10;                }&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;package&quot;, description = &quot;Create platform-specific installers&quot;)&#10;    static class PackageCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Override&#10;        public Integer call() throws Exception {&#10;            String os = System.getProperty(&quot;os.name&quot;).toLowerCase();&#10;            System.out.println(&quot;Creating installer for &quot; + os + &quot;...&quot;);&#10;            &#10;            if (os.contains(&quot;windows&quot;)) {&#10;                System.out.println(&quot;Windows installer options:&quot;);&#10;                System.out.println(&quot;1. Inno Setup (current) - Creates .exe installer&quot;);&#10;                System.out.println(&quot;2. WiX Toolset - Creates .msi installer&quot;);&#10;                System.out.println(&quot;3. jpackage - Creates .exe with bundled JRE&quot;);&#10;            } else if (os.contains(&quot;mac&quot;)) {&#10;                System.out.println(&quot;macOS installer options:&quot;);&#10;                System.out.println(&quot;1. jpackage --type dmg - Creates .dmg&quot;);&#10;                System.out.println(&quot;2. jpackage --type pkg - Creates .pkg&quot;);&#10;            } else if (os.contains(&quot;linux&quot;)) {&#10;                System.out.println(&quot;Linux installer options:&quot;);&#10;                System.out.println(&quot;1. jpackage --type deb - Creates .deb package&quot;);&#10;                System.out.println(&quot;2. jpackage --type rpm - Creates .rpm package&quot;);&#10;                System.out.println(&quot;3. AppImage - Portable application&quot;);&#10;            }&#10;            &#10;            return 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/JavaWizardApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/JavaWizardApplication.java" />
              <option name="updatedContent" value="package com.amankrmj.xwizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import com.amankrmj.xwizard.commands.PathCommand;&#10;import com.amankrmj.xwizard.java.JavaVersionManagerCommand;&#10;import com.amankrmj.xwizard.java.NativeCompilerCommand;&#10;&#10;/**&#10; * JavaWizard Application - Complete Java Development Environment Manager&#10; * &#10; * This is the main application class that serves as the entry point for&#10; * the JavaWizard command-line tool.&#10; */&#10;@Command(name = &quot;javawizard&quot;,&#10;         mixinStandardHelpOptions = true,&#10;         version = &quot;1.0.0&quot;,&#10;         description = &quot;JavaWizard - Complete Java Development Environment Manager&quot;,&#10;         subcommands = {&#10;             PathCommand.class,&#10;             JavaVersionManagerCommand.class,&#10;             NativeCompilerCommand.class&#10;         })&#10;public class JavaWizardApplication implements Runnable {&#10;&#10;    @Option(names = {&quot;-v&quot;, &quot;--verbose&quot;}, description = &quot;Enable verbose output&quot;)&#10;    private boolean verbose = false;&#10;&#10;    public boolean isVerbose() {&#10;        return verbose;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        System.out.println(&quot;JavaWizard - Complete Java Development Environment Manager&quot;);&#10;        System.out.println(&quot;Version: 1.0.0&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Available commands:&quot;);&#10;        System.out.println(&quot;  path     - Manage environment PATH variables&quot;);&#10;        System.out.println(&quot;  java     - Manage Java versions and installations&quot;);&#10;        System.out.println(&quot;  native   - Manage native compilation and cross-platform builds&quot;);&#10;        System.out.println();&#10;        System.out.println(&quot;Use 'javawizard &lt;command&gt; --help' for detailed help on each command.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Alternative entry point for the application&#10;     */&#10;    public static void main(String[] args) {&#10;        CommandLine cmd = new CommandLine(new JavaWizardApplication());&#10;        int exitCode = cmd.execute(args);&#10;        System.exit(exitCode);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/PathCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amankrmj/xwizard/PathCommand.java" />
              <option name="updatedContent" value="package com.amankrmj.xwizard;&#10;&#10;import picocli.CommandLine;&#10;import picocli.CommandLine.Command;&#10;import picocli.CommandLine.Option;&#10;import picocli.CommandLine.Parameters;&#10;&#10;import java.io.IOException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.concurrent.Callable;&#10;&#10;@Command(name = &quot;path&quot;,&#10;         description = &quot;Manage environment PATH variables&quot;,&#10;         subcommands = {&#10;             PathCommand.AddCommand.class,&#10;             PathCommand.RemoveCommand.class,&#10;             PathCommand.ListCommand.class&#10;         })&#10;public class PathCommand implements Callable&lt;Integer&gt; {&#10;&#10;    @Override&#10;    public Integer call() throws Exception {&#10;        System.out.println(&quot;Use 'path --help' to see available subcommands:&quot;);&#10;        System.out.println(&quot;  add    - Add directory to PATH&quot;);&#10;        System.out.println(&quot;  remove - Remove directory from PATH&quot;);&#10;        System.out.println(&quot;  list   - List current PATH entries&quot;);&#10;        return 0;&#10;    }&#10;&#10;    @Command(name = &quot;add&quot;, description = &quot;Add a directory to user PATH environment variable&quot;)&#10;    static class AddCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to add to PATH&quot;)&#10;        private String pathToAdd;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Add to system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-f&quot;, &quot;--force&quot;}, description = &quot;Add even if path already exists&quot;)&#10;        private boolean force = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                // Check if path already exists&#10;                if (!force &amp;&amp; isPathAlreadyInPATH(currentPath, pathToAdd)) {&#10;                    System.out.println(&quot;Path already exists in &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                    return 0;&#10;                }&#10;                &#10;                // Add to PATH&#10;                String newPath = currentPath.isEmpty() ? pathToAdd : currentPath + &quot;;&quot; + pathToAdd;&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully added to &quot; + scope + &quot; PATH: &quot; + pathToAdd);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error adding to PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;remove&quot;, description = &quot;Remove a directory from user PATH environment variable&quot;)&#10;    static class RemoveCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Parameters(index = &quot;0&quot;, description = &quot;Directory path to remove from PATH&quot;)&#10;        private String pathToRemove;&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Remove from system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                String currentPath = getCurrentPath(scope);&#10;                &#10;                if (!isPathAlreadyInPATH(currentPath, pathToRemove)) {&#10;                    System.out.println(&quot;Path not found in &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                    return 0;&#10;                }&#10;                &#10;                // Remove from PATH&#10;                String newPath = removePathFromPATH(currentPath, pathToRemove);&#10;                setPathVariable(scope, newPath);&#10;                &#10;                System.out.println(&quot;Successfully removed from &quot; + scope + &quot; PATH: &quot; + pathToRemove);&#10;                System.out.println(&quot;Note: Restart your terminal or IDE to see the changes.&quot;);&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error removing from PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;    }&#10;&#10;    @Command(name = &quot;list&quot;, description = &quot;List current PATH entries&quot;)&#10;    static class ListCommand implements Callable&lt;Integer&gt; {&#10;        &#10;        @Option(names = {&quot;-s&quot;, &quot;--system&quot;}, description = &quot;Show system PATH instead of user PATH&quot;)&#10;        private boolean systemPath = false;&#10;        &#10;        @Option(names = {&quot;-a&quot;, &quot;--all&quot;}, description = &quot;Show both user and system PATH&quot;)&#10;        private boolean showAll = false;&#10;&#10;        @Override&#10;        public Integer call() throws Exception {&#10;            try {&#10;                if (showAll) {&#10;                    System.out.println(&quot;=== USER PATH ===&quot;);&#10;                    listPath(&quot;USER&quot;);&#10;                    System.out.println(&quot;\n=== SYSTEM PATH ===&quot;);&#10;                    listPath(&quot;SYSTEM&quot;);&#10;                } else {&#10;                    String scope = systemPath ? &quot;SYSTEM&quot; : &quot;USER&quot;;&#10;                    System.out.println(&quot;=== &quot; + scope + &quot; PATH ===&quot;);&#10;                    listPath(scope);&#10;                }&#10;                return 0;&#10;                &#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error listing PATH: &quot; + e.getMessage());&#10;                return 1;&#10;            }&#10;        }&#10;        &#10;        private void listPath(String scope) throws IOException, InterruptedException {&#10;            String currentPath = getCurrentPath(scope);&#10;            if (currentPath.isEmpty()) {&#10;                System.out.println(&quot;No &quot; + scope + &quot; PATH entries found.&quot;);&#10;                return;&#10;            }&#10;            &#10;            String[] paths = currentPath.split(&quot;;&quot;);&#10;            for (int i = 0; i &lt; paths.length; i++) {&#10;                String path = paths[i].trim();&#10;                if (!path.isEmpty()) {&#10;                    System.out.println((i + 1) + &quot;. &quot; + path);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods&#10;    private static String getCurrentPath(String scope) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;query&quot;, hive + &quot;\\&quot; + key, &quot;/v&quot;, &quot;Path&quot;);&#10;        Process process = pb.start();&#10;        &#10;        String output = new String(process.getInputStream().readAllBytes());&#10;        process.waitFor();&#10;        &#10;        // Parse reg output to get PATH value&#10;        String[] lines = output.split(&quot;\n&quot;);&#10;        for (String line : lines) {&#10;            if (line.trim().startsWith(&quot;Path&quot;)) {&#10;                String[] parts = line.trim().split(&quot;\\s+&quot;, 3);&#10;                if (parts.length &gt;= 3) {&#10;                    return parts[2].trim();&#10;                }&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;    &#10;    private static void setPathVariable(String scope, String newPath) throws IOException, InterruptedException {&#10;        String hive = scope.equals(&quot;SYSTEM&quot;) ? &quot;HKLM&quot; : &quot;HKCU&quot;;&#10;        String key = scope.equals(&quot;SYSTEM&quot;) ? &#10;            &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot; :&#10;            &quot;Environment&quot;;&#10;            &#10;        ProcessBuilder pb = new ProcessBuilder(&quot;reg&quot;, &quot;add&quot;, hive + &quot;\\&quot; + key, &#10;            &quot;/v&quot;, &quot;Path&quot;, &quot;/t&quot;, &quot;REG_EXPAND_SZ&quot;, &quot;/d&quot;, newPath, &quot;/f&quot;);&#10;        Process process = pb.start();&#10;        &#10;        int exitCode = process.waitFor();&#10;        if (exitCode != 0) {&#10;            String error = new String(process.getErrorStream().readAllBytes());&#10;            throw new RuntimeException(&quot;Failed to update registry: &quot; + error);&#10;        }&#10;        &#10;        // Broadcast environment change&#10;        broadcastEnvironmentChange();&#10;    }&#10;    &#10;    private static boolean isPathAlreadyInPATH(String currentPath, String pathToCheck) {&#10;        if (currentPath.isEmpty()) return false;&#10;        &#10;        List&lt;String&gt; paths = Arrays.asList(currentPath.toLowerCase().split(&quot;;&quot;));&#10;        return paths.contains(pathToCheck.toLowerCase().trim());&#10;    }&#10;    &#10;    private static String removePathFromPATH(String currentPath, String pathToRemove) {&#10;        String[] paths = currentPath.split(&quot;;&quot;);&#10;        StringBuilder newPath = new StringBuilder();&#10;        &#10;        for (String path : paths) {&#10;            String trimmedPath = path.trim();&#10;            if (!trimmedPath.isEmpty() &amp;&amp; !trimmedPath.equalsIgnoreCase(pathToRemove.trim())) {&#10;                if (newPath.length() &gt; 0) {&#10;                    newPath.append(&quot;;&quot;);&#10;                }&#10;                newPath.append(trimmedPath);&#10;            }&#10;        }&#10;        &#10;        return newPath.toString();&#10;    }&#10;    &#10;    private static void broadcastEnvironmentChange() {&#10;        try {&#10;            // Notify system of environment changes&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;powershell&quot;, &quot;-Command&quot;, &#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', [System.Guid]::NewGuid().ToString(), 'User'); &quot; +&#10;                &quot;[System.Environment]::SetEnvironmentVariable('TEMP_REFRESH', $null, 'User')&quot;);&#10;            Process process = pb.start();&#10;            process.waitFor();&#10;        } catch (Exception e) {&#10;            // Silent fail - environment change broadcast is optional&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>